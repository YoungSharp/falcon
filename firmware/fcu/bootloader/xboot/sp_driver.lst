   1               	# 1 "sp_driver.S"
   1               	;******************************************************************************
   0               	
   0               	
   2               	;*
   3               	;* XMEGA Self-programming driver assembly source file.
   4               	;*
   5               	;*      This file contains the low-level implementations for the
   6               	;*      XMEGA Self-programming driver. It is written for the GCC Assembler.
   7               	;*
   8               	;*      If any SPM instructions are used, the linker file must define
   9               	;*      a segment named bootloader which must be located in the device Boot section.
  10               	;*      This can be done by passing "-Wl,--section-start=.BOOT=0x020000" to the
  11               	;*      linker with the correct address for the boot section.
  12               	;*
  13               	;*      None of these routines clean up the NVM Command Register after use.
  14               	;*      It is therefore important to write NVM_CMD_NO_OPERATION_gc (0x00) to this
  15               	;*      register when you are finished using any of the functions in this driver.
  16               	;*
  17               	;*      For all routines, it is important that any interrupt handlers do not
  18               	;*      perform any NVM operations. The user must implement a scheme for mutually
  19               	;*      exclusive access to the NVM. However, the 4-cycle timeout will work fine,
  20               	;*      since writing to the Configuration Change Protection register (CCP)
  21               	;*      automatically disables interrupts for 4 instruction cycles.
  22               	;*
  23               	;*      Note on IAR calling convention:
  24               	;*         Scratch registers:   R18-R27, R30-R31
  25               	;*         Preserved registers: R2-R17, R28-R29
  26               	;*         Parameter registers: R8-R25 (2-,4-, or 8- byte alignment)
  27               	;*         Return registers:    R18-R25 (up to 64-bit)
  28               	;*
  29               	;* Application note:
  30               	;*      AVR1316: XMEGA Self-programming
  31               	;*
  32               	;* Documentation
  33               	;*      For comprehensive code documentation, supported compilers, compiler
  34               	;*      settings and supported devices see readme.html
  35               	;*
  36               	;*      Atmel Corporation: http:;www.atmel.com \n
  37               	;*      Support email: avr@atmel.com
  38               	;*
  39               	;* $Revision: 1153 $
  40               	;* $Date: 2007-12-18 09:48:23 +0100 (ti, 18 des 2007) $
  41               	;*
  42               	;* Copyright (c) 2007, Atmel Corporation All rights reserved.
  43               	;*
  44               	;* Redistribution and use in source and binary forms, with or without
  45               	;* modification, are permitted provided that the following conditions are met:
  46               	;*
  47               	;* 1. Redistributions of source code must retain the above copyright notice,
  48               	;* this list of conditions and the following disclaimer.
  49               	;*
  50               	;* 2. Redistributions in binary form must reproduce the above copyright notice,
  51               	;* this list of conditions and the following disclaimer in the documentation
  52               	;* and/or other materials provided with the distribution.
  53               	;*
  54               	;* 3. The name of ATMEL may not be used to endorse or promote products derived
  55               	;* from this software without specific prior written permission.
  56               	;*
  57               	;* THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  58               	;* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  59               	;* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
  60               	;* SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
  61               	;* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  62               	;* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  63               	;* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  64               	;* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  65               	;* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  66               	;* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  67               	;******************************************************************************
  68               	
  69               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h,v 1.52.2.23 2009/04/25 21:01:29 arcanum Exp $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega16M1__)
 128               	#  include <avr/iom16m1.h>
 129               	#elif defined (__AVR_ATmega16U4__)
 130               	#  include <avr/iom16u4.h>
 131               	#elif defined (__AVR_ATmega32C1__)
 132               	#  include <avr/iom32c1.h>
 133               	#elif defined (__AVR_ATmega32M1__)
 134               	#  include <avr/iom32m1.h>
 135               	#elif defined (__AVR_ATmega32U4__)
 136               	#  include <avr/iom32u4.h>
 137               	#elif defined (__AVR_ATmega32U6__)
 138               	#  include <avr/iom32u6.h>
 139               	#elif defined (__AVR_ATmega64C1__)
 140               	#  include <avr/iom64c1.h>
 141               	#elif defined (__AVR_ATmega64M1__)
 142               	#  include <avr/iom64m1.h>
 143               	#elif defined (__AVR_ATmega128__)
 144               	#  include <avr/iom128.h>
 145               	#elif defined (__AVR_ATmega1280__)
 146               	#  include <avr/iom1280.h>
 147               	#elif defined (__AVR_ATmega1281__)
 148               	#  include <avr/iom1281.h>
 149               	#elif defined (__AVR_ATmega1284P__)
 150               	#  include <avr/iom1284p.h>
 151               	#elif defined (__AVR_ATmega128RFA1__)
 152               	#  include <avr/iom128rfa1.h>
 153               	#elif defined (__AVR_ATmega2560__)
 154               	#  include <avr/iom2560.h>
 155               	#elif defined (__AVR_ATmega2561__)
 156               	#  include <avr/iom2561.h>
 157               	#elif defined (__AVR_AT90CAN32__)
 158               	#  include <avr/iocan32.h>
 159               	#elif defined (__AVR_AT90CAN64__)
 160               	#  include <avr/iocan64.h>
 161               	#elif defined (__AVR_AT90CAN128__)
 162               	#  include <avr/iocan128.h>
 163               	#elif defined (__AVR_AT90USB82__)
 164               	#  include <avr/iousb82.h>
 165               	#elif defined (__AVR_AT90USB162__)
 166               	#  include <avr/iousb162.h>
 167               	#elif defined (__AVR_AT90USB646__)
 168               	#  include <avr/iousb646.h>
 169               	#elif defined (__AVR_AT90USB647__)
 170               	#  include <avr/iousb647.h>
 171               	#elif defined (__AVR_AT90USB1286__)
 172               	#  include <avr/iousb1286.h>
 173               	#elif defined (__AVR_AT90USB1287__)
 174               	#  include <avr/iousb1287.h>
 175               	#elif defined (__AVR_ATmega64__)
 176               	#  include <avr/iom64.h>
 177               	#elif defined (__AVR_ATmega640__)
 178               	#  include <avr/iom640.h>
 179               	#elif defined (__AVR_ATmega644__)
 180               	#  include <avr/iom644.h>
 181               	#elif defined (__AVR_ATmega644P__)
 182               	#  include <avr/iom644p.h>
 183               	#elif defined (__AVR_ATmega645__)
 184               	#  include <avr/iom645.h>
 185               	#elif defined (__AVR_ATmega6450__)
 186               	#  include <avr/iom6450.h>
 187               	#elif defined (__AVR_ATmega649__)
 188               	#  include <avr/iom649.h>
 189               	#elif defined (__AVR_ATmega6490__)
 190               	#  include <avr/iom6490.h>
 191               	#elif defined (__AVR_ATmega103__)
 192               	#  include <avr/iom103.h>
 193               	#elif defined (__AVR_ATmega32__)
 194               	#  include <avr/iom32.h>
 195               	#elif defined (__AVR_ATmega323__)
 196               	#  include <avr/iom323.h>
 197               	#elif defined (__AVR_ATmega324P__)
 198               	#  include <avr/iom324.h>
 199               	#elif defined (__AVR_ATmega325__)
 200               	#  include <avr/iom325.h>
 201               	#elif defined (__AVR_ATmega325P__)
 202               	#  include <avr/iom325.h>
 203               	#elif defined (__AVR_ATmega3250__)
 204               	#  include <avr/iom3250.h>
 205               	#elif defined (__AVR_ATmega3250P__)
 206               	#  include <avr/iom3250.h>
 207               	#elif defined (__AVR_ATmega328P__)
 208               	#  include <avr/iom328p.h>
 209               	#elif defined (__AVR_ATmega329__)
 210               	#  include <avr/iom329.h>
 211               	#elif defined (__AVR_ATmega329P__)
 212               	#  include <avr/iom329.h>
 213               	#elif defined (__AVR_ATmega3290__)
 214               	#  include <avr/iom3290.h>
 215               	#elif defined (__AVR_ATmega3290P__)
 216               	#  include <avr/iom3290.h>
 217               	#elif defined (__AVR_ATmega32HVB__)
 218               	#  include <avr/iom32hvb.h>
 219               	#elif defined (__AVR_ATmega406__)
 220               	#  include <avr/iom406.h>
 221               	#elif defined (__AVR_ATmega16__)
 222               	#  include <avr/iom16.h>
 223               	#elif defined (__AVR_ATmega161__)
 224               	#  include <avr/iom161.h>
 225               	#elif defined (__AVR_ATmega162__)
 226               	#  include <avr/iom162.h>
 227               	#elif defined (__AVR_ATmega163__)
 228               	#  include <avr/iom163.h>
 229               	#elif defined (__AVR_ATmega164P__)
 230               	#  include <avr/iom164.h>
 231               	#elif defined (__AVR_ATmega165__)
 232               	#  include <avr/iom165.h>
 233               	#elif defined (__AVR_ATmega165P__)
 234               	#  include <avr/iom165p.h>
 235               	#elif defined (__AVR_ATmega168__)
 236               	#  include <avr/iom168.h>
 237               	#elif defined (__AVR_ATmega168P__)
 238               	#  include <avr/iom168p.h>
 239               	#elif defined (__AVR_ATmega169__)
 240               	#  include <avr/iom169.h>
 241               	#elif defined (__AVR_ATmega169P__)
 242               	#  include <avr/iom169p.h>
 243               	#elif defined (__AVR_ATmega8HVA__)
 244               	#  include <avr/iom8hva.h>
 245               	#elif defined (__AVR_ATmega16HVA__)
 246               	#  include <avr/iom16hva.h>
 247               	#elif defined (__AVR_ATmega8__)
 248               	#  include <avr/iom8.h>
 249               	#elif defined (__AVR_ATmega48__)
 250               	#  include <avr/iom48.h>
 251               	#elif defined (__AVR_ATmega48P__)
 252               	#  include <avr/iom48p.h>
 253               	#elif defined (__AVR_ATmega88__)
 254               	#  include <avr/iom88.h>
 255               	#elif defined (__AVR_ATmega88P__)
 256               	#  include <avr/iom88p.h>
 257               	#elif defined (__AVR_ATmega8515__)
 258               	#  include <avr/iom8515.h>
 259               	#elif defined (__AVR_ATmega8535__)
 260               	#  include <avr/iom8535.h>
 261               	#elif defined (__AVR_AT90S8535__)
 262               	#  include <avr/io8535.h>
 263               	#elif defined (__AVR_AT90C8534__)
 264               	#  include <avr/io8534.h>
 265               	#elif defined (__AVR_AT90S8515__)
 266               	#  include <avr/io8515.h>
 267               	#elif defined (__AVR_AT90S4434__)
 268               	#  include <avr/io4434.h>
 269               	#elif defined (__AVR_AT90S4433__)
 270               	#  include <avr/io4433.h>
 271               	#elif defined (__AVR_AT90S4414__)
 272               	#  include <avr/io4414.h>
 273               	#elif defined (__AVR_ATtiny22__)
 274               	#  include <avr/iotn22.h>
 275               	#elif defined (__AVR_ATtiny26__)
 276               	#  include <avr/iotn26.h>
 277               	#elif defined (__AVR_AT90S2343__)
 278               	#  include <avr/io2343.h>
 279               	#elif defined (__AVR_AT90S2333__)
 280               	#  include <avr/io2333.h>
 281               	#elif defined (__AVR_AT90S2323__)
 282               	#  include <avr/io2323.h>
 283               	#elif defined (__AVR_AT90S2313__)
 284               	#  include <avr/io2313.h>
 285               	#elif defined (__AVR_ATtiny2313__)
 286               	#  include <avr/iotn2313.h>
 287               	#elif defined (__AVR_ATtiny13__)
 288               	#  include <avr/iotn13.h>
 289               	#elif defined (__AVR_ATtiny13A__)
 290               	#  include <avr/iotn13a.h>
 291               	#elif defined (__AVR_ATtiny25__)
 292               	#  include <avr/iotn25.h>
 293               	#elif defined (__AVR_ATtiny45__)
 294               	#  include <avr/iotn45.h>
 295               	#elif defined (__AVR_ATtiny85__)
 296               	#  include <avr/iotn85.h>
 297               	#elif defined (__AVR_ATtiny24__)
 298               	#  include <avr/iotn24.h>
 299               	#elif defined (__AVR_ATtiny44__)
 300               	#  include <avr/iotn44.h>
 301               	#elif defined (__AVR_ATtiny84__)
 302               	#  include <avr/iotn84.h>
 303               	#elif defined (__AVR_ATtiny261__)
 304               	#  include <avr/iotn261.h>
 305               	#elif defined (__AVR_ATtiny461__)
 306               	#  include <avr/iotn461.h>
 307               	#elif defined (__AVR_ATtiny861__)
 308               	#  include <avr/iotn861.h>
 309               	#elif defined (__AVR_ATtiny43U__)
 310               	#  include <avr/iotn43u.h>
 311               	#elif defined (__AVR_ATtiny48__)
 312               	#  include <avr/iotn48.h>
 313               	#elif defined (__AVR_ATtiny88__)
 314               	#  include <avr/iotn88.h>
 315               	#elif defined (__AVR_ATtiny87__)
 316               	#  include <avr/iotn87.h>
 317               	#elif defined (__AVR_ATtiny167__)
 318               	#  include <avr/iotn167.h>
 319               	#elif defined (__AVR_AT90SCR100__)
 320               	#  include <avr/io90scr100.h>
 321               	#elif defined (__AVR_ATxmega16A4__)
 322               	#  include <avr/iox16a4.h>
 323               	#elif defined (__AVR_ATxmega16D4__)
 324               	#  include <avr/iox16d4.h>
 325               	#elif defined (__AVR_ATxmega32A4__)
 326               	#  include <avr/iox32a4.h>
 327               	#elif defined (__AVR_ATxmega32D4__)
 328               	#  include <avr/iox32d4.h>
 329               	#elif defined (__AVR_ATxmega64A1__)
 330               	#  include <avr/iox64a1.h>
 331               	#elif defined (__AVR_ATxmega64A3__)
 332               	#  include <avr/iox64a3.h>
 333               	#elif defined (__AVR_ATxmega64D3__)
 334               	#  include <avr/iox64d3.h>
 335               	#elif defined (__AVR_ATxmega128A1__)
 336               	#  include <avr/iox128a1.h>
 337               	#elif defined (__AVR_ATxmega128A3__)
 338               	#  include <avr/iox128a3.h>
   1               	/* Copyright (c) 2009 Atmel Corporation
 339               	#elif defined (__AVR_ATxmega128D3__)
 340               	#  include <avr/iox128d3.h>
 341               	#elif defined (__AVR_ATxmega192A3__)
 342               	#  include <avr/iox192a3.h>
 343               	#elif defined (__AVR_ATxmega256A3__)
 344               	#  include <avr/iox256a3.h>
 345               	#elif defined (__AVR_ATxmega256A3B__)
 346               	#  include <avr/iox256a3b.h>
 347               	#elif defined (__AVR_ATxmega256D3__)
 348               	#  include <avr/iox256d3.h>
 349               	#elif defined (__AVR_ATA6289__)
 350               	#  include <avr/ioa6289.h>
 351               	/* avr1: the following only supported for assembler programs */
 352               	#elif defined (__AVR_ATtiny28__)
 353               	#  include <avr/iotn28.h>
 354               	#elif defined (__AVR_AT90S1200__)
 355               	#  include <avr/io1200.h>
 356               	#elif defined (__AVR_ATtiny15__)
 357               	#  include <avr/iotn15.h>
 358               	#elif defined (__AVR_ATtiny12__)
 359               	#  include <avr/iotn12.h>
 360               	#elif defined (__AVR_ATtiny11__)
 361               	#  include <avr/iotn11.h>
 362               	#else
 363               	#  if !defined(__COMPILING_AVR_LIBC__)
 364               	#    warning "device type not defined"
 365               	#  endif
 366               	#endif
 367               	
 368               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 369               	
 370               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 371               	
 372               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 373               	
 374               	/* Include fuse.h after individual IO header files. */
 375               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 376               	
 377               	/* Include lock.h after individual IO header files. */
 378               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 379               	
  70               	;#include "Flash_Defines.h"
  71               	
  72               	/* Define the size of the flash page if not defined in the header files. */
  73               	#ifndef APP_SECTION_PAGE_SIZE
  74               		#error  APP_SECTION_PAGE_SIZE must be defined if not defined in header files.
  75               		//#define APP_SECTION_PAGE_SIZE 512
  76               	#endif /*APP_SECTION_PAGE_SIZE*/
  77               	
  78               	/* Defines not yet included in header file. */
  79               	#define NVM_CMD_NO_OPERATION_gc (0x00<<0)	// Noop/Ordinary LPM
  80               	#define NVM_CMD_READ_USER_SIG_ROW_gc (0x01<<0)	// Read user signature row
  81               	#define NVM_CMD_READ_CALIB_ROW_gc (0x02<<0)	// Read calibration row
  82               	#define NVM_CMD_READ_EEPROM_gc (0x06<<0)	// Read EEPROM
  83               	#define NVM_CMD_READ_FUSES_gc (0x07<<0)	// Read fuse byte
  84               	#define NVM_CMD_WRITE_LOCK_BITS_gc (0x08<<0)	// Write lock bits
  85               	#define NVM_CMD_ERASE_USER_SIG_ROW_gc (0x18<<0)	// Erase user signature row
  86               	#define NVM_CMD_WRITE_USER_SIG_ROW_gc (0x1A<<0)	// Write user signature row
  87               	#define NVM_CMD_ERASE_APP_gc (0x20<<0)	// Erase Application Section
  88               	#define NVM_CMD_ERASE_APP_PAGE_gc (0x22<<0)	// Erase Application Section page
  89               	#define NVM_CMD_LOAD_FLASH_BUFFER_gc (0x23<<0)	// Load Flash page buffer
  90               	#define NVM_CMD_WRITE_APP_PAGE_gc (0x24<<0)	// Write Application Section page
  91               	#define NVM_CMD_ERASE_WRITE_APP_PAGE_gc (0x25<<0)	// Erase-and-write Application Section page
  92               	#define NVM_CMD_ERASE_FLASH_BUFFER_gc (0x26<<0)	// Erase/flush Flash page buffer
  93               	#define NVM_CMD_ERASE_BOOT_PAGE_gc (0x2A<<0)	// Erase Boot Section page
  94               	#define NVM_CMD_WRITE_BOOT_PAGE_gc (0x2C<<0)	// Write Boot Section page
  95               	#define NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc (0x2D<<0)	// Erase-and-write Boot Section page
  96               	#define NVM_CMD_ERASE_EEPROM_gc (0x30<<0)	// Erase EEPROM
  97               	#define NVM_CMD_ERASE_EEPROM_PAGE_gc (0x32<<0)	// Erase EEPROM page
  98               	#define NVM_CMD_LOAD_EEPROM_BUFFER_gc (0x33<<0)	// Load EEPROM page buffer
  99               	#define NVM_CMD_WRITE_EEPROM_PAGE_gc (0x34<<0)	// Write EEPROM page
 100               	#define NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc (0x35<<0)	// Erase-and-write EEPROM page
 101               	#define NVM_CMD_ERASE_EEPROM_BUFFER_gc (0x36<<0)	// Erase/flush EEPROM page buffer
 102               	#define NVM_CMD_APP_CRC_gc (0x38<<0)	// Generate Application section CRC
 103               	#define NVM_CMD_BOOT_CRC_gc (0x39<<0)	// Generate Boot Section CRC
 104               	#define NVM_CMD_FLASH_RANGE_CRC_gc (0x3A<<0)	// Generate Flash Range CRC
 105               	#define CCP_SPM_gc (0x9D<<0)	// SPM Instruction Protection
 106               	#define CCP_IOREG_gc (0xD8<<0)	// IO Register Protection
 107               	
 108               	
 109               	
 110               	; ---
 111               	; This routine reads a byte from flash given by the address in
 112               	; R25:R24:R23:R22.
 113               	;
 114               	; Input:
 115               	;     R25:R24:R23:R22.
 116               	;
 117               	; Returns:
 118               	;     R24 - Read byte.
 119               	; ---
 120               	
 121               	.section .text
 122               	.global SP_ReadByte
 123               	
 124               	SP_ReadByte:
 124:sp_driver.S   **** 	in	r19, RAMPZ      ; Save RAMPZ.
 125:sp_driver.S   **** 	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
 126:sp_driver.S   **** 	movw	ZL, r22         ; Move the low bytes to the Z pointer
 127:sp_driver.S   **** 	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
 128:sp_driver.S   **** 	out	RAMPZ, r19      ; Restore RAMPZ register.
 129:sp_driver.S   **** 	ret
 131               	
 132               	
 133               	
 134               	; ---
 135               	; This routine reads a word from flash given by the address in
 136               	; R25:R24:R23:R22.
 137               	;
 138               	; Input:
 139               	;     R25:R24:R23:R22.
 140               	;
 141               	; Returns:
 142               	;     R25:R24 - Read word.
 143               	; ---
 144               	
 145               	.section .text
 146               	.global SP_ReadWord
 147               	
 148               	SP_ReadWord:
 148:sp_driver.S   **** 	in	r19, RAMPZ      ; Save RAMPZ.
 149:sp_driver.S   **** 	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
 150:sp_driver.S   **** 	movw	ZL, r22         ; Move the low bytes to the Z pointer
 151:sp_driver.S   **** 	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
 152:sp_driver.S   **** 	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
 153:sp_driver.S   **** 	out	RAMPZ, r19      ; Restore RAMPZ register.
 154:sp_driver.S   **** 	ret
 156               	
 157               	
 158               	
 159               	; ---
 160               	; This routine reads the calibration byte given by the index in R24.
 161               	;
 162               	; Input:
 163               	;     R24 - Byte index.
 164               	;
 165               	; Returns:
 166               	;     R24 - Calibration byte.
 167               	; ---
 168               	
 169               	.section .text
 170               	.global SP_ReadCalibrationByte	
 171               	
 172               	SP_ReadCalibrationByte:
 172:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
 173:sp_driver.S   **** 	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
 175               	
 176               	
 177               	
 178               	; ---
 179               	; This routine reads the user signature byte given by the index in R25:R24.
 180               	;
 181               	; Input:
 182               	;     R25:R24 - Byte index.
 183               	;
 184               	; Returns:
 185               	;     R24 - Signature byte.
 186               	; ---
 187               	
 188               	.section .text	
 189               	.global SP_ReadUserSignatureByte
 190               	
 191               	SP_ReadUserSignatureByte:
 191:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
 192:sp_driver.S   **** 	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
 194               	
 195               	
 196               	
 197               	; ---
 198               	; This routine reads the fuse byte given by the index in R24.
 199               	;
 200               	; Input:
 201               	;     R24 - Byte index.
 202               	;
 203               	; Returns:
 204               	;     R24 - Fuse byte.
 205               	; ---
 206               	
 207               	.section .text	
 208               	.global SP_ReadFuseByte
 209               	
 210               	SP_ReadFuseByte:
 210:sp_driver.S   **** 	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
 211:sp_driver.S   **** 	clr	r24                         ; Prepare a zero.
 212:sp_driver.S   **** 	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
 213:sp_driver.S   **** 	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
 214:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
 215:sp_driver.S   **** 	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
 216:sp_driver.S   **** 	movw	r24, r22                    ; Move low byte to 1 byte return address.
 217:sp_driver.S   **** 	ret
 219               	
 220               	
 221               	
 222               	; ---
 223               	; This routine sets the lock bits from R24. Note that unlocking is only
 224               	; possible by doing a full chip erase, not available from software.
 225               	;
 226               	; Input:
 227               	;     R24 - Lock bits.
 228               	;
 229               	; Returns:
 230               	;     Nothing.
 231               	; ---
 232               	
 233               	.section .text	
 234               	.global SP_WriteLockBits
 235               	
 236               	SP_WriteLockBits:
 236:sp_driver.S   **** 	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
 237:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
 238:sp_driver.S   **** 	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
 240               	
 241               	
 242               	
 243               	; ---
 244               	; This routine reads the lock bits.
 245               	;
 246               	; Input:
 247               	;     Nothing.
 248               	;
 249               	; Returns:
 250               	;     R24 - Lock bits.
 251               	; ---
 252               	
 253               	.section .text		
 254               	.global SP_ReadLockBits
 255               	
 256               	SP_ReadLockBits:
 256:sp_driver.S   **** 	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
 257:sp_driver.S   **** 	ret
 259               	
 260               	
 261               	
 262               	; ---
 263               	; This routine erases the user signature row.
 264               	;
 265               	; Input:
 266               	;     Nothing.
 267               	;
 268               	; Returns:
 269               	;     Nothing.
 270               	; ---
 271               	
 272               	.section .text
 273               	.global SP_EraseUserSignatureRow
 274               	
 275               	SP_EraseUserSignatureRow:
 275:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 276:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
 277:sp_driver.S   **** 	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
 279               	
 280               	
 281               	
 282               	; ---
 283               	; This routine writes the flash buffer to the user signature row.
 284               	;
 285               	; Input:
 286               	;     Nothing.
 287               	;
 288               	; Returns:
 289               	;     Nothing.
 290               	; ---
 291               	
 292               	.section .text
 293               	.global SP_WriteUserSignatureRow
 294               	
 295               	SP_WriteUserSignatureRow:
 295:sp_driver.S   **** 	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
 296:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
 297:sp_driver.S   **** 	jmp	SP_CommonSPM                        ; Jump to common SPM code.
 299               	
 300               	
 301               	
 302               	; ---
 303               	; This routine erases the entire application section.
 304               	;
 305               	; Input:
 306               	;     Nothing.
 307               	;
 308               	; Returns:
 309               	;     Nothing.
 310               	; ---
 311               	
 312               	.section .text
 313               	.global SP_EraseApplicationSection
 314               	
 315               	SP_EraseApplicationSection:
 315:sp_driver.S   **** 	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
 316:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
 317:sp_driver.S   **** 	jmp	SP_CommonSPM               ; Jump to common SPM code.
 319               	
 320               	
 321               	
 322               	; ---
 323               	; This routine erases the page at address R25:R24:R23:R22 in the application
 324               	; section. The address can point anywhere inside the page.
 325               	;
 326               	; Input:
 327               	;     R25:R24:R23:R22 - Byte address into Flash page.
 328               	;
 329               	; Returns:
 330               	;     Nothing.
 331               	; ---
 332               	
 333               	.section .text	
 334               	.global SP_EraseApplicationPage
 335               	
 336               	SP_EraseApplicationPage:
 336:sp_driver.S   **** 	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
 337:sp_driver.S   **** 	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
 338:sp_driver.S   **** 	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
 339:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
 340:sp_driver.S   **** 	jmp	SP_CommonSPM                    ; Jump to common SPM code.
 342               	
 343               	
 344               	
 345               	; ---
 346               	; This routine writes the word from R23:R22 into the Flash page buffer at
 347               	; address R25:R24.
 348               	;
 349               	; Input:
 350               	;     R25:R24 - Byte address into Flash page.
 351               	;     R23:R22 - Word to write.
 352               	;
 353               	; Returns:
 354               	;     Nothing.
 355               	; ---
 356               	
 357               	.section .text
 358               	.global SP_LoadFlashWord
 359               	
 360               	SP_LoadFlashWord:
 360:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 361:sp_driver.S   **** 	movw	r0, r22                            ; Prepare flash word in R1:R0.
 362:sp_driver.S   **** 	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
 363:sp_driver.S   **** 	jmp	SP_CommonSPM                       ; Jump to common SPM code.
 365               	
 366               	
 367               	
 368               	; ---
 369               	; This routine writes an entire page from the SRAM buffer at
 370               	; address R25:R24 into the Flash page buffer.
 371               	;
 372               	; Note that you must define "-Wl,--section-start=.BOOT=0x020000" for the
 373               	; linker to place this function in the boot section with the correct address.
 374               	;
 375               	; Input:
 376               	;     R25:R24 - 16-bit pointer to SRAM buffer.
 377               	;
 378               	; Returns:
 379               	;     Nothing.
 380               	; ---
 381               			
 382               	.section .BOOT, "ax"
 383               	.global SP_LoadFlashPage
 384               	
 385               	SP_LoadFlashPage:
 385:sp_driver.S   **** 	clr	ZL              ; Clear low byte of Z, to indicate start of page.
 386:sp_driver.S   **** 	clr	ZH              ; Clear high byte of Z, to indicate start of page.
 388               	
 388:sp_driver.S   **** 	out	RAMPX, r1       ; Clear RAMPX pointer.
 389:sp_driver.S   **** 	movw	XL, r24         ; Load X with data buffer address.
 391               	
 391:sp_driver.S   **** 	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
 392:sp_driver.S   **** 	sts	NVM_CMD, r20                       ; Load it into NVM command register.
 394               	
 395               	#if APP_SECTION_PAGE_SIZE > 512
 396               		ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8)
 397               	#endif
 398               	
 398:sp_driver.S   **** 	ldi	r21, ((APP_SECTION_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
 399:sp_driver.S   **** 	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
 401               	
 402               	SP_LoadFlashPage_1:
 402:sp_driver.S   **** 	ld	r0, X+         ; Load low byte from buffer into R0.
 403:sp_driver.S   **** 	ld	r1, X+         ; Load high byte from buffer into R1.
 404:sp_driver.S   **** 	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
 405:sp_driver.S   **** 	spm                    ; Self-program.
 406:sp_driver.S   **** 	adiw	ZL, 2          ; Move Z to next Flash word.
 408               	
 409               	#if APP_SECTION_PAGE_SIZE > 512
 410               		subi	r21, 1         ; Decrement word count.
 411               		sbci	r22, 0
 412               	#else
 412:sp_driver.S   **** 	dec	r21            ; Decrement word count.
 414               	#endif
 415               	
 415:sp_driver.S   **** 	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
 417               	
 417:sp_driver.S   **** 	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
 418:sp_driver.S   **** 	ret
 420               	
 421               	
 422               	
 423               	; ---
 424               	; This routine reads an entire Flash page from address R23:R22:R21:R20 into the
 425               	; SRAM buffer at address R25:R24.
 426               	;
 427               	;
 428               	; Input:
 429               	;     R23:R22:R21:R20 - Flash byte address.
 430               	;     R25:R24 - 16-bit pointer to SRAM buffer.
 431               	;
 432               	; Returns:
 433               	;     Nothing.
 434               	; ---
 435               	
 436               	.section .text		
 437               	.global SP_ReadFlashPage
 438               	
 439               	SP_ReadFlashPage:
 440               	
 440:sp_driver.S   **** 	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
 441:sp_driver.S   **** 	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
 442:sp_driver.S   **** 	movw    ZL, r20                      ; Load Z with Flash address.
 444               	
 444:sp_driver.S   **** 	out	RAMPX, r1                    ; Load RAMPX with data pointer
 445:sp_driver.S   **** 	movw	XL, r24                      ; Load X with data buffer address.
 447               	
 447:sp_driver.S   **** 	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
 448:sp_driver.S   **** 	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
 450               	
 451               	#if APP_SECTION_PAGE_SIZE > 512
 452               		ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
 453               	#endif	
 454               	
 454:sp_driver.S   **** 	ldi	r21, ((APP_SECTION_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
 456               	
 457               	SP_ReadFlashPage_1:
 457:sp_driver.S   **** 	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
 458:sp_driver.S   **** 	elpm	r25, Z+
 459:sp_driver.S   **** 	st	X+, r24                         ; Write bytes to buffer.
 460:sp_driver.S   **** 	st	X+, r25
 462               	
 463               	#if APP_SECTION_PAGE_SIZE > 512
 464               		subi	r21, 1                          ; Decrement word count.
 465               		sbci	r22, 0
 466               	#else
 466:sp_driver.S   **** 	dec	r21                             ; Decrement word count.
 468               	#endif	
 469               	
 469:sp_driver.S   **** 	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
 471               	
 471:sp_driver.S   **** 	out	RAMPZ, r19
 472:sp_driver.S   **** 	ret
 474               	
 475               	
 476               	
 477               	; ---
 478               	; This routine writes the page buffer to the Flash page at address R25:R24:R23:R22
 479               	; in the application section. The address can point anywhere inside the page.
 480               	;
 481               	; Input:
 482               	;     R25:R24:R23:R22 - Byte address into Flash page.
 483               	;
 484               	; Returns:
 485               	;     Nothing.
 486               	; ---
 487               	
 488               	.section .text		
 489               	.global SP_WriteApplicationPage
 490               	
 491               	SP_WriteApplicationPage:
 491:sp_driver.S   **** 	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
 492:sp_driver.S   **** 	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
 493:sp_driver.S   **** 	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
 494:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
 495:sp_driver.S   **** 	jmp	SP_CommonSPM                     ; Jump to common SPM code.
 497               	
 498               	
 499               	
 500               	; ---
 501               	; This routine erases first and then writes the page buffer to the
 502               	; Flash page at address R25:R24:R23:R22 in the application section. The address
 503               	; can point anywhere inside the page.
 504               	;
 505               	; Input:
 506               	;     R25:R24:R23:R22 - Byte address into Flash page.
 507               	;
 508               	; Returns:
 509               	;     Nothing.
 510               	; ---
 511               	
 512               	.section .text
 513               	.global SP_EraseWriteApplicationPage
 514               	
 515               	SP_EraseWriteApplicationPage:
 515:sp_driver.S   **** 	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
 516:sp_driver.S   **** 	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
 517:sp_driver.S   **** 	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
 518:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
 519:sp_driver.S   **** 	jmp	SP_CommonSPM                          ; Jump to common SPM code.
 521               	
 522               	
 523               	
 524               	; ---
 525               	; This routine flushes the Flash page buffer.
 526               	;
 527               	; Input:
 528               	;     Nothing.
 529               	;
 530               	; Returns:
 531               	;     Nothing.
 532               	; ---
 533               	
 534               	.section .text		
 535               	.global SP_EraseFlashBuffer
 536               	
 537               	SP_EraseFlashBuffer:
 537:sp_driver.S   **** 	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
 538:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
 539:sp_driver.S   **** 	jmp	SP_CommonSPM                        ; Jump to common SPM code.
 541               	
 542               	
 543               	
 544               	; ---
 545               	; This routine erases the page at address R25:R24:R23:R22 in the Boot section. The
 546               	; address can point anywhere inside the page.
 547               	;
 548               	; Input:
 549               	;     R25:R24:R23:R22 - Byte address into Flash page.
 550               	;
 551               	; Returns:
 552               	;     Nothing.
 553               	; ---
 554               	
 555               	.section .text		
 556               	.global SP_EraseBootPage
 557               	
 558               	SP_EraseBootPage:
 558:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 559:sp_driver.S   **** 	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
 560:sp_driver.S   **** 	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
 561:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
 562:sp_driver.S   **** 	jmp	SP_CommonSPM                       ; Jump to common SPM code.
 564               	
 565               	
 566               	
 567               	; ---
 568               	; This routine writes the page buffer to the Flash page at address R25:R24:R23:R22
 569               	; in the BOOT section. The address can point anywhere inside the page.
 570               	;
 571               	; Input:
 572               	;     R25:R24:R23:R22 - Byte address into Flash page.
 573               	;
 574               	; Returns:
 575               	;     Nothing.
 576               	; ---
 577               	
 578               	.section .text		
 579               	.global SP_WriteBootPage
 580               	
 581               	SP_WriteBootPage:
 581:sp_driver.S   **** 	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
 582:sp_driver.S   **** 	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
 583:sp_driver.S   **** 	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
 584:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
 585:sp_driver.S   **** 	jmp	SP_CommonSPM                     ; Jump to common SPM code.
 587               	
 588               	
 589               	
 590               	; ---
 591               	; This routine erases first and then writes the page buffer to the
 592               	; Flash page at address R25:R24:R23:R22 in the Boot section. The address
 593               	; can point anywhere inside the page.
 594               	;
 595               	; Input:
 596               	;     R25:R24:R23:R22 - Byte address into Flash page.
 597               	;
 598               	; Returns:
 599               	;     Nothing.
 600               	; ---
 601               	
 602               	.section .text		
 603               	.global SP_EraseWriteBootPage
 604               	
 605               	SP_EraseWriteBootPage:
 605:sp_driver.S   **** 	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
 606:sp_driver.S   **** 	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
 607:sp_driver.S   **** 	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
 608:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
 609:sp_driver.S   **** 	jmp	SP_CommonSPM                           ; Jump to common SPM code.
 611               	
 612               	
 613               	
 614               	; ---
 615               	; This routine calculates a CRC for the application section.
 616               	;
 617               	; Input:
 618               	;     Nothing.
 619               	;
 620               	; Returns:
 621               	;     R25:R24:R23:R22 - 32-bit CRC result (actually only 24-bit used).
 622               	; ---
 623               	
 624               	.section .text	
 625               	.global SP_ApplicationCRC
 626               	
 627               	SP_ApplicationCRC:
 627:sp_driver.S   **** 	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
 628:sp_driver.S   **** 	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
 630               	
 631               	
 632               	
 633               	; ---
 634               	; This routine calculates a CRC for the Boot section.
 635               	;
 636               	; Input:
 637               	;     Nothing.
 638               	;
 639               	; Returns:
 640               	;     R25:R24:R23:R22 - 32-bit CRC result (actually only 24-bit used).
 641               	; ---
 642               	
 643               	.section .text
 644               	.global SP_BootCRC
 645               	
 646               	SP_BootCRC:
 646:sp_driver.S   **** 	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
 647:sp_driver.S   **** 	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
 649               	
 650               	
 651               	
 652               	; ---
 653               	; This routine locks all further access to SPM operations until next reset.
 654               	;
 655               	; Input:
 656               	;     Nothing.
 657               	;
 658               	; Returns:
 659               	;     Nothing.
 660               	; ---
 661               	
 662               	.section .text
 663               	.global SP_LockSPM
 664               	
 665               	SP_LockSPM:
 665:sp_driver.S   **** 	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
 666:sp_driver.S   **** 	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
 667:sp_driver.S   **** 	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
 668:sp_driver.S   **** 	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
 669:sp_driver.S   **** 	ret
 671               		
 672               	
 673               	
 674               	; ---
 675               	; This routine wait for the SPM to finish and clears the command register.
 676               	;
 677               	; Note that this routine is blocking, and will halt any execution until the SPM
 678               	; is finished.
 679               	;
 680               	; Input:
 681               	;     Nothing.
 682               	;
 683               	; Returns:
 684               	;     Nothing.
 685               	; ---
 686               	
 687               	.section .text
 688               	.global SP_WaitForSPM		
 689               	
 690               	SP_WaitForSPM:
 690:sp_driver.S   **** 	lds	r18, NVM_STATUS     ; Load the NVM Status register.
 691:sp_driver.S   **** 	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
 692:sp_driver.S   **** 	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
 693:sp_driver.S   **** 	clr	r18
 694:sp_driver.S   **** 	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
 695:sp_driver.S   **** 	ret
 697               	
 698               	
 699               	
 700               	; ---
 701               	; This routine is called by several other routines, and contains common code
 702               	; for executing an NVM command, including the return statement itself.
 703               	;
 704               	; If the operation (NVM command) requires the NVM Address registers to be
 705               	; prepared, this must be done before jumping to this routine.
 706               	;
 707               	; Note that R25:R24:R23:R22 is used for returning results, even if the
 708               	; C-domain calling function only expects a single byte or even void.
 709               	;
 710               	; Input:
 711               	;     R20 - NVM Command code.
 712               	;
 713               	; Returns:
 714               	;     R25:R24:R23:R22 - 32-bit result from NVM operation.
 715               	; ---
 716               	
 717               	.section .text		
 718               	
 719               	SP_CommonCMD:
 719:sp_driver.S   **** 	sts	NVM_CMD, r20        ; Load command into NVM Command register.
 720:sp_driver.S   **** 	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
 721:sp_driver.S   **** 	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
 722:sp_driver.S   **** 	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
 723:sp_driver.S   **** 	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
 724:sp_driver.S   **** 	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
 725:sp_driver.S   **** 	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
 726:sp_driver.S   **** 	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
 727:sp_driver.S   **** 	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
 728:sp_driver.S   **** 	ret
 730               	
 731               	
 732               	
 733               	; ---
 734               	; This routine is called by several other routines, and contains common code
 735               	; for executing an LPM command, including the return statement itself.
 736               	;
 737               	; Note that R24 is used for returning results, even if the
 738               	; C-domain calling function expects a void.
 739               	;
 740               	; Input:
 741               	;     R25:R24 - Low bytes of Z pointer.
 742               	;     R20     - NVM Command code.
 743               	;
 744               	; Returns:
 745               	;     R24     - Result from LPM operation.
 746               	; ---
 747               	
 748               	.section .text		
 749               	
 750               	SP_CommonLPM:
 750:sp_driver.S   **** 	movw	ZL, r24             ; Load index into Z.
 751:sp_driver.S   **** 	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
 752:sp_driver.S   **** 	lpm	r24,Z
 753:sp_driver.S   **** 	ret
 755               	
 756               	
 757               	
 758               	; ---
 759               	; This routine is called by several other routines, and contains common code
 760               	; for executing an SPM command, including the return statement itself.
 761               	;
 762               	; If the operation (SPM command) requires the R1:R0 registers to be
 763               	; prepared, this must be done before jumping to this routine.
 764               	;
 765               	; Note that you must define "-Wl,--section-start=.BOOT=0x020000" for the
 766               	; linker to place this function in the boot section with the correct address.
 767               	;
 768               	; Input:
 769               	;     R1:R0    - Optional input to SPM command.
 770               	;     R25:R24  - Low bytes of Z pointer.
 771               	;     R20      - NVM Command code.
 772               	;
 773               	; Returns:
 774               	;     Nothing.
 775               	; ---
 776               	
 777               	.section .BOOT, "ax"
 778               	
 779               	SP_CommonSPM:
 779:sp_driver.S   **** 	movw	ZL, r24          ; Load R25:R24 into Z.
 780:sp_driver.S   **** 	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
 781:sp_driver.S   **** 	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
 782:sp_driver.S   **** 	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
 783:sp_driver.S   **** 	spm                      ; Self-program.
 784:sp_driver.S   **** 	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
 785:sp_driver.S   **** 	out	RAMPZ, r19       ; Restore RAMPZ register.
 786:sp_driver.S   **** 	ret
 788               		
 789               		
 790               	; END OF FILE
DEFINED SYMBOLS
         sp_driver.S:124    .text:00000000 SP_ReadByte
         sp_driver.S:148    .text:0000000c SP_ReadWord
         sp_driver.S:172    .text:0000001a SP_ReadCalibrationByte
         sp_driver.S:750    .text:00000120 SP_CommonLPM
         sp_driver.S:191    .text:0000001e SP_ReadUserSignatureByte
         sp_driver.S:210    .text:00000022 SP_ReadFuseByte
         sp_driver.S:719    .text:00000100 SP_CommonCMD
         sp_driver.S:236    .text:00000038 SP_WriteLockBits
         sp_driver.S:256    .text:00000040 SP_ReadLockBits
         sp_driver.S:275    .text:00000046 SP_EraseUserSignatureRow
         sp_driver.S:779    .BOOT:00000026 SP_CommonSPM
         sp_driver.S:295    .text:0000004e SP_WriteUserSignatureRow
         sp_driver.S:315    .text:00000056 SP_EraseApplicationSection
         sp_driver.S:336    .text:0000005e SP_EraseApplicationPage
         sp_driver.S:360    .text:0000006a SP_LoadFlashWord
         sp_driver.S:385    .BOOT:00000000 SP_LoadFlashPage
         sp_driver.S:402    .BOOT:00000012 SP_LoadFlashPage_1
         sp_driver.S:439    .text:00000074 SP_ReadFlashPage
         sp_driver.S:457    .text:00000086 SP_ReadFlashPage_1
         sp_driver.S:491    .text:00000096 SP_WriteApplicationPage
         sp_driver.S:515    .text:000000a2 SP_EraseWriteApplicationPage
         sp_driver.S:537    .text:000000ae SP_EraseFlashBuffer
         sp_driver.S:558    .text:000000b6 SP_EraseBootPage
         sp_driver.S:581    .text:000000c2 SP_WriteBootPage
         sp_driver.S:605    .text:000000ce SP_EraseWriteBootPage
         sp_driver.S:627    .text:000000da SP_ApplicationCRC
         sp_driver.S:646    .text:000000de SP_BootCRC
         sp_driver.S:665    .text:000000e2 SP_LockSPM
         sp_driver.S:690    .text:000000f0 SP_WaitForSPM

NO UNDEFINED SYMBOLS
