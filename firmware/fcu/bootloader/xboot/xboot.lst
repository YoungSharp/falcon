   1               		.file	"xboot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 397               	.global	get_char
 399               	get_char:
   0:xboot.c       **** /************************************************************************/
   1:xboot.c       **** /* XBoot Extensible AVR Bootloader                                      */
   2:xboot.c       **** /*                                                                      */
   3:xboot.c       **** /* tested with ATXMEGA64A3, ATXMEGA128A1, ATXMEGA256A1, ATXMEGA32A4     */
   4:xboot.c       **** /*                                                                      */
   5:xboot.c       **** /* xboot.c                                                              */
   6:xboot.c       **** /*                                                                      */
   7:xboot.c       **** /* Alex Forencich <alex@alexforencich.com>                              */
   8:xboot.c       **** /*                                                                      */
   9:xboot.c       **** /* Copyright (c) 2010 Alex Forencich                                    */
  10:xboot.c       **** /*                                                                      */
  11:xboot.c       **** /* Permission is hereby granted, free of charge, to any person          */
  12:xboot.c       **** /* obtaining a copy of this software and associated documentation       */
  13:xboot.c       **** /* files(the "Software"), to deal in the Software without restriction,  */
  14:xboot.c       **** /* including without limitation the rights to use, copy, modify, merge, */
  15:xboot.c       **** /* publish, distribute, sublicense, and/or sell copies of the Software, */
  16:xboot.c       **** /* and to permit persons to whom the Software is furnished to do so,    */
  17:xboot.c       **** /* subject to the following conditions:                                 */
  18:xboot.c       **** /*                                                                      */
  19:xboot.c       **** /* The above copyright notice and this permission notice shall be       */
  20:xboot.c       **** /* included in all copies or substantial portions of the Software.      */
  21:xboot.c       **** /*                                                                      */
  22:xboot.c       **** /* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      */
  23:xboot.c       **** /* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   */
  24:xboot.c       **** /* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                */
  25:xboot.c       **** /* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  */
  26:xboot.c       **** /* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   */
  27:xboot.c       **** /* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN    */
  28:xboot.c       **** /* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE     */
  29:xboot.c       **** /* SOFTWARE.                                                            */
  30:xboot.c       **** /*                                                                      */
  31:xboot.c       **** /************************************************************************/
  32:xboot.c       **** 
  33:xboot.c       **** #include "xboot.h"
  34:xboot.c       **** 
  35:xboot.c       **** #ifdef USE_INTERRUPTS
  36:xboot.c       **** volatile unsigned char comm_mode;
  37:xboot.c       **** 
  38:xboot.c       **** volatile unsigned char rx_buff0;
  39:xboot.c       **** volatile unsigned char rx_buff1;
  40:xboot.c       **** volatile unsigned char rx_char_cnt;
  41:xboot.c       **** 
  42:xboot.c       **** volatile unsigned char tx_buff0;
  43:xboot.c       **** volatile unsigned char tx_char_cnt;
  44:xboot.c       **** #else
  45:xboot.c       **** unsigned char comm_mode;
  46:xboot.c       **** #endif // USE_INTERRUPTS
  47:xboot.c       **** 
  48:xboot.c       **** // Main code
  49:xboot.c       **** int main(void)
  50:xboot.c       **** {
  51:xboot.c       ****         ADDR_T address = 0;
  52:xboot.c       ****         unsigned char in_bootloader = 0;
  53:xboot.c       ****         unsigned char val = 0;
  54:xboot.c       ****         int i, j, k;
  55:xboot.c       ****         void (*reset_vect)( void ) = 0x000000;
  56:xboot.c       ****         
  57:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
  58:xboot.c       ****         unsigned short devid_bit;
  59:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
  60:xboot.c       ****         
  61:xboot.c       ****         comm_mode = MODE_UNDEF;
  62:xboot.c       ****         
  63:xboot.c       ****         #ifdef USE_INTERRUPTS
  64:xboot.c       ****         rx_char_cnt = 0;
  65:xboot.c       ****         tx_char_cnt = 0;
  66:xboot.c       ****         #endif // USE_INTERRUPTS
  67:xboot.c       ****         
  68:xboot.c       ****         // Initialization section
  69:xboot.c       ****         // Entry point and communication methods are initialized here
  70:xboot.c       ****         // --------------------------------------------------
  71:xboot.c       ****         
  72:xboot.c       ****         #ifdef USE_32MHZ_RC
  73:xboot.c       ****         #if (F_CPU != 32000000L)
  74:xboot.c       ****         #error F_CPU must match oscillator setting!
  75:xboot.c       ****         #endif
  76:xboot.c       ****         #ifdef __AVR_XMEGA__
  77:xboot.c       ****         OSC.CTRL |= OSC_RC32MEN_bm; // turn on 32 MHz oscillator
  78:xboot.c       ****         while (!(OSC.STATUS & OSC_RC32MRDY_bm)) { }; // wait for it to start
  79:xboot.c       ****         CCP = CCP_IOREG_gc;
  80:xboot.c       ****         CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
  81:xboot.c       ****         #ifdef USE_DFLL
  82:xboot.c       ****         DFLLRC32M.CTRL = DFLL_ENABLE_bm;
  83:xboot.c       ****         #endif // USE_DFLL
  84:xboot.c       ****         #endif // __AVR_XMEGA__
  85:xboot.c       ****         #else
  86:xboot.c       ****         #if (F_CPU != 2000000L)
  87:xboot.c       ****         #error F_CPU must match oscillator setting!
  88:xboot.c       ****         #endif
  89:xboot.c       ****         #ifdef __AVR_XMEGA__
  90:xboot.c       ****         #ifdef USE_DFLL
  91:xboot.c       ****         DFLLRC2M.CTRL = DFLL_ENABLE_bm;
  92:xboot.c       ****         #endif // USE_DFLL
  93:xboot.c       ****         #endif // __AVR_XMEGA__
  94:xboot.c       ****         #endif
  95:xboot.c       ****         
  96:xboot.c       ****         #ifdef NEED_INTERRUPTS
  97:xboot.c       ****         // remap interrupts to boot section
  98:xboot.c       ****         CCP = CCP_IOREG_gc;
  99:xboot.c       ****         #ifdef USE_INTERRUPTS
 100:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 101:xboot.c       ****         #else
 102:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm;
 103:xboot.c       ****         #endif // USE_INTERRUPTS
 104:xboot.c       ****         #endif // NEED_INTERRUPTS
 105:xboot.c       ****         
 106:xboot.c       ****         #ifdef USE_LED
 107:xboot.c       ****         // Initialize LED pin
 108:xboot.c       ****         LED_PORT.DIRSET = (1 << LED_PIN);
 109:xboot.c       ****         #if LED_PIN_INV
 110:xboot.c       ****         LED_PORT.OUTCLR = (1 << LED_PIN);
 111:xboot.c       ****         #else
 112:xboot.c       ****         LED_PORT.OUTSET = (1 << LED_PIN);
 113:xboot.c       ****         #endif // LED_PIN_INV
 114:xboot.c       ****         #endif // USE_LED
 115:xboot.c       ****         
 116:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 117:xboot.c       ****         #ifdef USE_ATTACH_LED
 118:xboot.c       ****         // Initialize ATTACH_LED
 119:xboot.c       ****         ATTACH_LED_PORT.DIRSET = (1 << ATTACH_LED_PIN);
 120:xboot.c       ****         #if ATTACH_LED_INV
 121:xboot.c       ****         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_PIN);
 122:xboot.c       ****         #else
 123:xboot.c       ****         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_PIN);
 124:xboot.c       ****         #endif // ATTACH_LED_INV
 125:xboot.c       ****         #endif // USE_ATTACH_LED
 126:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 127:xboot.c       ****         
 128:xboot.c       ****         #ifdef USE_ENTER_PIN
 129:xboot.c       ****         // Make sure it's an input
 130:xboot.c       ****         ENTER_PORT.DIRCLR = (1 << ENTER_PIN);
 131:xboot.c       ****         #if ENTER_PIN_PUEN
 132:xboot.c       ****         // Enable bootloader entry pin pullup
 133:xboot.c       ****         ENTER_PIN_CTRL = 0x18;
 134:xboot.c       ****         #endif
 135:xboot.c       ****         #endif
 136:xboot.c       ****         
 137:xboot.c       ****         #ifdef USE_UART
 138:xboot.c       ****         // Initialize UART
 139:xboot.c       ****         uart_init();
 140:xboot.c       ****         #endif // USE_UART
 141:xboot.c       ****         
 142:xboot.c       ****         #ifdef USE_I2C
 143:xboot.c       ****         // Initialize I2C interface
 144:xboot.c       ****         i2c_init();
 145:xboot.c       ****         
 146:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 147:xboot.c       ****         I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN);
 148:xboot.c       ****         I2C_AUTONEG_PORT.OUTCLR = (1 << I2C_AUTONEG_PIN);
 149:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 150:xboot.c       ****         
 151:xboot.c       ****         #endif // USE_I2C
 152:xboot.c       ****         
 153:xboot.c       ****         // --------------------------------------------------
 154:xboot.c       ****         // End initialization section
 155:xboot.c       ****         
 156:xboot.c       ****         // One time trigger section
 157:xboot.c       ****         // Triggers that are checked once, regardless of
 158:xboot.c       ****         // whether or not USE_ENTER_DELAY is selected
 159:xboot.c       ****         // --------------------------------------------------
 160:xboot.c       ****         
 161:xboot.c       ****         
 162:xboot.c       ****         
 163:xboot.c       ****         // --------------------------------------------------
 164:xboot.c       ****         // End one time trigger section
 165:xboot.c       ****         
 166:xboot.c       **** #ifdef USE_ENTER_DELAY
 167:xboot.c       ****         k = ENTER_BLINK_COUNT*2;
 168:xboot.c       ****         j = ENTER_BLINK_WAIT;
 169:xboot.c       ****         while (!in_bootloader && k > 0)
 170:xboot.c       ****         {
 171:xboot.c       ****                 if (j-- <= 0)
 172:xboot.c       ****                 {
 173:xboot.c       ****                         #ifdef USE_LED
 174:xboot.c       ****                         LED_PORT.OUTTGL = (1 << LED_PIN);
 175:xboot.c       ****                         #endif // USE_LED
 176:xboot.c       ****                         j = ENTER_BLINK_WAIT;
 177:xboot.c       ****                         k--;
 178:xboot.c       ****                 }
 179:xboot.c       **** #else // USE_ENTER_DELAY
 180:xboot.c       ****                 // Need a small delay when not running loop
 181:xboot.c       ****                 // so we don't accidentally enter the bootloader
 182:xboot.c       ****                 // on power-up with USE_ENTER_PIN selected
 183:xboot.c       ****                 asm("nop");
 184:xboot.c       ****                 asm("nop");
 185:xboot.c       ****                 asm("nop");
 186:xboot.c       ****                 asm("nop");
 187:xboot.c       **** #endif // USE_ENTER_DELAY
 188:xboot.c       ****                 
 189:xboot.c       ****                 // Main trigger section
 190:xboot.c       ****                 // Set in_bootloader here to enter the bootloader
 191:xboot.c       ****                 // Checked when USE_ENTER_DELAY is selected
 192:xboot.c       ****                 // --------------------------------------------------
 193:xboot.c       ****                 
 194:xboot.c       ****                 #ifdef USE_ENTER_PIN
 195:xboot.c       ****                 // Check entry pin state
 196:xboot.c       ****                 if ((ENTER_PORT.IN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0))
 197:xboot.c       ****                         in_bootloader = 1;
 198:xboot.c       ****                 #endif // USE_ENTER_PIN
 199:xboot.c       ****                 
 200:xboot.c       ****                 #ifdef USE_ENTER_UART
 201:xboot.c       ****                 // Check for received character
 202:xboot.c       ****                 #ifdef __AVR_XMEGA__
 203:xboot.c       ****                 if (uart_char_received())
 204:xboot.c       ****                 {
 205:xboot.c       ****                         in_bootloader = 1;
 206:xboot.c       ****                         comm_mode = MODE_UART;
 207:xboot.c       ****                 }
 208:xboot.c       ****                 #endif // __AVR_XMEGA__
 209:xboot.c       ****                 
 210:xboot.c       ****                 #endif // USE_ENTER_UART
 211:xboot.c       ****                 
 212:xboot.c       ****                 #ifdef USE_ENTER_I2C
 213:xboot.c       ****                 // Check for address match condition
 214:xboot.c       ****                 if (i2c_address_match())
 215:xboot.c       ****                 {
 216:xboot.c       ****                         in_bootloader = 1;
 217:xboot.c       ****                         comm_mode = MODE_I2C;
 218:xboot.c       ****                 }
 219:xboot.c       ****                 #endif // USE_ENTER_I2C
 220:xboot.c       ****                 
 221:xboot.c       ****                 // --------------------------------------------------
 222:xboot.c       ****                 // End main trigger section
 223:xboot.c       ****                 
 224:xboot.c       ****         #ifdef USE_ENTER_DELAY
 225:xboot.c       ****         }
 226:xboot.c       ****         #endif // USE_ENTER_DELAY
 227:xboot.c       ****         
 228:xboot.c       ****         #ifdef USE_INTERRUPTS
 229:xboot.c       ****         // Enable interrupts
 230:xboot.c       ****         sei();
 231:xboot.c       ****         #endif // USE_INTERRUPTS
 232:xboot.c       **** 
 233:xboot.c       ****         #ifdef USE_WATCHDOG
 234:xboot.c       ****         WDT_EnableAndSetTimeout();
 235:xboot.c       ****         #endif // USE_WATCHDOG
 236:xboot.c       **** 
 237:xboot.c       ****         // Main bootloader        
 238:xboot.c       ****         while (in_bootloader) {
 239:xboot.c       ****                 #ifdef USE_LED
 240:xboot.c       ****                 LED_PORT.OUTTGL = (1 << LED_PIN);
 241:xboot.c       ****                 #endif // USE_LED
 242:xboot.c       ****                 
 243:xboot.c       ****                 val = get_char();
 244:xboot.c       **** 
 245:xboot.c       ****                 #ifdef USE_WATCHDOG
 246:xboot.c       ****                 WDT_Reset();
 247:xboot.c       ****                 #endif // USE_WATCHDOG
 248:xboot.c       **** 
 249:xboot.c       ****                 // Main bootloader parser
 250:xboot.c       ****                 // check autoincrement status
 251:xboot.c       ****                 if (val == 'a')
 252:xboot.c       ****                 {
 253:xboot.c       ****                         // yes, it is supported
 254:xboot.c       ****                         send_char('Y');
 255:xboot.c       ****                 }
 256:xboot.c       ****                 // Set address
 257:xboot.c       ****                 else if (val == 'A')
 258:xboot.c       ****                 {
 259:xboot.c       ****                         // Read address high then low
 260:xboot.c       ****                         address = (((ADDR_T)get_char() << 8) | (ADDR_T)get_char()) & 0x0000FFFF;
 261:xboot.c       ****                         // acknowledge
 262:xboot.c       ****                         send_char('\r');
 263:xboot.c       ****                 }
 264:xboot.c       ****                 // Extended address
 265:xboot.c       ****                 else if (val == 'H')
 266:xboot.c       ****                 {
 267:xboot.c       ****                         // Read address high then low
 268:xboot.c       ****                         address = (((ADDR_T)get_char() << 16) | ((ADDR_T)get_char() << 8) | (ADDR_T
 269:xboot.c       ****                         // acknowledge
 270:xboot.c       ****                         send_char('\r');
 271:xboot.c       ****                 }
 272:xboot.c       ****                 // Chip erase
 273:xboot.c       ****                 else if (val == 'e')
 274:xboot.c       ****                 {
 275:xboot.c       ****                         for (address = 0; address < APP_SECTION_SIZE; address += APP_SECTION_PAGE_S
 276:xboot.c       ****                         {
 277:xboot.c       ****                                 #ifdef USE_WATCHDOG
 278:xboot.c       ****                                 WDT_Reset();
 279:xboot.c       ****                                 #endif // USE_WATCHDOG
 280:xboot.c       ****                                 // wait for SPM instruction to complete
 281:xboot.c       ****                                 SP_WaitForSPM();
 282:xboot.c       ****                                 // erase page
 283:xboot.c       ****                                 SP_EraseApplicationPage(address);
 284:xboot.c       ****                         }
 285:xboot.c       ****                         
 286:xboot.c       ****                         // Randomize page buffer
 287:xboot.c       ****                         EEPROM_LoadPage(&val);
 288:xboot.c       ****                         // Erase EEPROM
 289:xboot.c       ****                         EEPROM_EraseAll();
 290:xboot.c       ****                         
 291:xboot.c       ****                         // acknowledge
 292:xboot.c       ****                         send_char('\r');
 293:xboot.c       ****                 }
 294:xboot.c       ****                 #ifdef ENABLE_BLOCK_SUPPORT
 295:xboot.c       ****                 // Check block load support
 296:xboot.c       ****                 else if (val == 'b')
 297:xboot.c       ****                 {
 298:xboot.c       ****                         // yes, it is supported
 299:xboot.c       ****                         send_char('Y');
 300:xboot.c       ****                         // Send block size (page size)
 301:xboot.c       ****                         send_char((APP_SECTION_PAGE_SIZE >> 8) & 0xFF);
 302:xboot.c       ****                         send_char(APP_SECTION_PAGE_SIZE & 0xFF);
 303:xboot.c       ****                 }
 304:xboot.c       ****                 // Block load
 305:xboot.c       ****                 else if (val == 'B')
 306:xboot.c       ****                 {
 307:xboot.c       ****                         // Block size
 308:xboot.c       ****                         i = (get_char() << 8) | get_char();
 309:xboot.c       ****                         // Memory type
 310:xboot.c       ****                         val = get_char();
 311:xboot.c       ****                         // Load it
 312:xboot.c       ****                         send_char(BlockLoad(i, val, &address));
 313:xboot.c       ****                 }
 314:xboot.c       ****                 // Block read
 315:xboot.c       ****                 else if (val == 'g')
 316:xboot.c       ****                 {
 317:xboot.c       ****                         // Block size
 318:xboot.c       ****                         i = (get_char() << 8) | get_char();
 319:xboot.c       ****                         // Memory type
 320:xboot.c       ****                         val = get_char();
 321:xboot.c       ****                         // Read it
 322:xboot.c       ****                         BlockRead(i, val, &address);
 323:xboot.c       ****                 }
 324:xboot.c       ****                 #endif // ENABLE_BLOCK_SUPPORT
 325:xboot.c       ****                 #ifdef ENABLE_FLASH_BYTE_SUPPORT
 326:xboot.c       ****                 // Read program memory byte
 327:xboot.c       ****                 else if (val == 'R')
 328:xboot.c       ****                 {
 329:xboot.c       ****                         SP_WaitForSPM();
 330:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+1));
 331:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+0));
 332:xboot.c       ****                         
 333:xboot.c       ****                         address++;
 334:xboot.c       ****                 }
 335:xboot.c       ****                 // Write program memory low byte
 336:xboot.c       ****                 else if (val == 'c')
 337:xboot.c       ****                 {
 338:xboot.c       ****                         // get low byte
 339:xboot.c       ****                         i = get_char();
 340:xboot.c       ****                         send_char('\r');
 341:xboot.c       ****                 }
 342:xboot.c       ****                 // Write program memory high byte
 343:xboot.c       ****                 else if (val == 'C')
 344:xboot.c       ****                 {
 345:xboot.c       ****                         // get high byte; combine
 346:xboot.c       ****                         i |= (get_char() << 8);
 347:xboot.c       ****                         SP_WaitForSPM();
 348:xboot.c       ****                         SP_LoadFlashWord((address << 1), i);
 349:xboot.c       ****                         address++;
 350:xboot.c       ****                         send_char('\r');
 351:xboot.c       ****                 }
 352:xboot.c       ****                 // Write page
 353:xboot.c       ****                 else if (val == 'm')
 354:xboot.c       ****                 {
 355:xboot.c       ****                         if (address >= (APP_SECTION_SIZE>>1))
 356:xboot.c       ****                         {
 357:xboot.c       ****                                 // don't allow bootloader overwrite
 358:xboot.c       ****                                 send_char('?');
 359:xboot.c       ****                         }
 360:xboot.c       ****                         else
 361:xboot.c       ****                         {
 362:xboot.c       ****                                 SP_WaitForSPM();
 363:xboot.c       ****                                 SP_WriteApplicationPage( address << 1);
 364:xboot.c       ****                                 send_char('\r');
 365:xboot.c       ****                         }
 366:xboot.c       ****                 }
 367:xboot.c       ****                 #endif // ENABLE_FLASH_BYTE_SUPPORT
 368:xboot.c       ****                 #ifdef ENABLE_EEPROM_BYTE_SUPPORT
 369:xboot.c       ****                 // Write EEPROM memory
 370:xboot.c       ****                 else if (val == 'D')
 371:xboot.c       ****                 {
 372:xboot.c       ****                         EEPROM_WriteByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (unsigned ch
 373:xboot.c       ****                         address++;
 374:xboot.c       ****                 }
 375:xboot.c       ****                 // Read EEPROM memory
 376:xboot.c       ****                 else if (val == 'd')
 377:xboot.c       ****                 {
 378:xboot.c       ****                         send_char( EEPROM_ReadByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (u
 379:xboot.c       ****                         address++;
 380:xboot.c       ****                 }
 381:xboot.c       ****                 #endif // ENABLE_EEPROM_BYTE_SUPPORT
 382:xboot.c       ****                 #ifdef ENABLE_LOCK_BITS
 383:xboot.c       ****                 // Write lockbits
 384:xboot.c       ****                 else if (val == 'l')
 385:xboot.c       ****                 {
 386:xboot.c       ****                         SP_WaitForSPM();
 387:xboot.c       ****                         SP_WriteLockBits( get_char() );
 388:xboot.c       ****                         send_char('\r');
 389:xboot.c       ****                 }
 390:xboot.c       ****                 // Read lockbits
 391:xboot.c       ****                 else if (val == 'r')
 392:xboot.c       ****                 {
 393:xboot.c       ****                         SP_WaitForSPM();
 394:xboot.c       ****                         send_char(SP_ReadLockBits());
 395:xboot.c       ****                 }
 396:xboot.c       ****                 #endif // ENABLE_LOCK_BITS
 397:xboot.c       ****                 #ifdef ENABLE_FUSE_BITS
 398:xboot.c       ****                 // Read low fuse bits
 399:xboot.c       ****                 else if (val == 'F')
 400:xboot.c       ****                 {
 401:xboot.c       ****                         SP_WaitForSPM();
 402:xboot.c       ****                         send_char(SP_ReadFuseByte(0));
 403:xboot.c       ****                 }
 404:xboot.c       ****                 // Read high fuse bits
 405:xboot.c       ****                 else if (val == 'N')
 406:xboot.c       ****                 {
 407:xboot.c       ****                         SP_WaitForSPM();
 408:xboot.c       ****                         send_char(SP_ReadFuseByte(1));
 409:xboot.c       ****                 }
 410:xboot.c       ****                 // Read extended fuse bits
 411:xboot.c       ****                 else if (val == 'Q')
 412:xboot.c       ****                 {
 413:xboot.c       ****                         SP_WaitForSPM();
 414:xboot.c       ****                         send_char(SP_ReadFuseByte(2));
 415:xboot.c       ****                 }
 416:xboot.c       ****                 #endif // ENABLE_FUSE_BITS
 417:xboot.c       ****                 // Enter and leave programming mode
 418:xboot.c       ****                 else if ((val == 'P') || (val == 'L'))
 419:xboot.c       ****                 {
 420:xboot.c       ****                         // just acknowledge
 421:xboot.c       ****                         send_char('\r');
 422:xboot.c       ****                 }
 423:xboot.c       ****                 // Exit bootloader
 424:xboot.c       ****                 else if (val == 'E')
 425:xboot.c       ****                 {
 426:xboot.c       ****                         in_bootloader = 0;
 427:xboot.c       ****                         send_char('\r');
 428:xboot.c       ****                 }
 429:xboot.c       ****                 // Get programmer type
 430:xboot.c       ****                 else if (val == 'p')
 431:xboot.c       ****                 {
 432:xboot.c       ****                         // serial
 433:xboot.c       ****                         send_char('S');
 434:xboot.c       ****                 }
 435:xboot.c       ****                 // Return supported device codes
 436:xboot.c       ****                 else if (val == 't')
 437:xboot.c       ****                 {
 438:xboot.c       ****                         // send only this device
 439:xboot.c       ****                         send_char(123); // TODO
 440:xboot.c       ****                         // terminator
 441:xboot.c       ****                         send_char(0);
 442:xboot.c       ****                 }
 443:xboot.c       ****                 // Set LED, clear LED, and set device type
 444:xboot.c       ****                 else if ((val == 'x') || (val == 'y') || (val == 'T'))
 445:xboot.c       ****                 {
 446:xboot.c       ****                         // discard parameter
 447:xboot.c       ****                         get_char();
 448:xboot.c       ****                         send_char('\r');
 449:xboot.c       ****                 }
 450:xboot.c       ****                 // Return program identifier
 451:xboot.c       ****                 else if (val == 'S')
 452:xboot.c       ****                 {
 453:xboot.c       ****                         send_char('X');
 454:xboot.c       ****                         send_char('B');
 455:xboot.c       ****                         send_char('o');
 456:xboot.c       ****                         send_char('o');
 457:xboot.c       ****                         send_char('t');
 458:xboot.c       ****                         send_char('+');
 459:xboot.c       ****                         send_char('+');
 460:xboot.c       ****                 }
 461:xboot.c       ****                 // Read software version
 462:xboot.c       ****                 else if (val == 'V')
 463:xboot.c       ****                 {
 464:xboot.c       ****                         send_char('1');
 465:xboot.c       ****                         send_char('6');
 466:xboot.c       ****                 }
 467:xboot.c       ****                 // Read signature bytes
 468:xboot.c       ****                 else if (val == 's')
 469:xboot.c       ****                 {
 470:xboot.c       ****                         send_char(SIGNATURE_2);
 471:xboot.c       ****                         send_char(SIGNATURE_1);
 472:xboot.c       ****                         send_char(SIGNATURE_0);
 473:xboot.c       ****                 }
 474:xboot.c       ****                 #ifdef USE_I2C
 475:xboot.c       ****                 #ifdef USE_I2C_ADDRESS_NEGOTIATION
 476:xboot.c       ****                 // Enter autonegotiate mode
 477:xboot.c       ****                 else if (val == '@')
 478:xboot.c       ****                 {
 479:xboot.c       ****                         // The address autonegotiation protocol is borrowed from the
 480:xboot.c       ****                         // OneWire address detection method.  The algorthim Utilizes
 481:xboot.c       ****                         // one extra shared wire, pulled up by resistors just like the
 482:xboot.c       ****                         // main I2C bus, a OneWire bus, or a wired-AND IRQ line.
 483:xboot.c       ****                         // The protocol involves intelligently guessing all of the
 484:xboot.c       ****                         // connected devices' 88 bit unique hardware ID numbers, stored
 485:xboot.c       ****                         // permanently in the production signature row during manufacture
 486:xboot.c       ****                         // (see XMega series datasheet for details)
 487:xboot.c       ****                         #ifdef __AVR_XMEGA__
 488:xboot.c       ****                         // k is temp
 489:xboot.c       ****                         // devid is pointer to current bit, init to first bit
 490:xboot.c       ****                         // of the hardware ID in the production signature row
 491:xboot.c       ****                         devid_bit = 0x08 << 3;
 492:xboot.c       ****                         // read first byte of hardware ID into temporary location
 493:xboot.c       ****                         k = SP_ReadCalibrationByte(0x08);
 494:xboot.c       ****                         
 495:xboot.c       ****                         // main negotiation loop
 496:xboot.c       ****                         while (1)
 497:xboot.c       ****                         {
 498:xboot.c       ****                                 // wait for incoming data
 499:xboot.c       ****                                 while (1)
 500:xboot.c       ****                                 {
 501:xboot.c       ****                                         // check for bit read command
 502:xboot.c       ****                                         if (!(I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN)))
 503:xboot.c       ****                                         {
 504:xboot.c       ****                                                 // write current bit of hardware ID
 505:xboot.c       ****                                                 ow_slave_write_bit(k & 1);  // write bit
 506:xboot.c       ****                                                 break;
 507:xboot.c       ****                                         }
 508:xboot.c       ****                                         // check for I2C bus activity
 509:xboot.c       ****                                         else if (I2C_DEVICE.SLAVE.STATUS & (TWI_SLAVE_APIF_bm | TWI
 510:xboot.c       ****                                         {
 511:xboot.c       ****                                                 // grab a byte
 512:xboot.c       ****                                                 // (there will be no I2C bus activity while
 513:xboot.c       ****                                                 // the autonegotiation is taking place,
 514:xboot.c       ****                                                 // so it's OK to block)
 515:xboot.c       ****                                                 val = get_char();
 516:xboot.c       ****                                                 // Is this an address byte for me?
 517:xboot.c       ****                                                 if (val == '#')
 518:xboot.c       ****                                                 {
 519:xboot.c       ****                                                         // If so, we're now attached, so light
 520:xboot.c       ****                                                         // the LED and update the I2C bus
 521:xboot.c       ****                                                         // controller accordingly
 522:xboot.c       ****                                                         
 523:xboot.c       ****                                                         // turn on attach LED
 524:xboot.c       ****                                                         #ifdef USE_ATTACH_LED
 525:xboot.c       ****                                                         #if ATTACH_LED_INV
 526:xboot.c       ****                                                         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_P
 527:xboot.c       ****                                                         #else
 528:xboot.c       ****                                                         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_P
 529:xboot.c       ****                                                         #endif // ATTACH_LED_INV
 530:xboot.c       ****                                                         #endif // USE_ATTACH_LED
 531:xboot.c       ****                                                         
 532:xboot.c       ****                                                         // get new address
 533:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_GC
 534:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = get_char() << 1;
 535:xboot.c       ****                                                         #else
 536:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = (get_char() << 1) |
 537:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_GC
 538:xboot.c       ****                                                         
 539:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_PROMISC
 540:xboot.c       ****                                                         // turn off promiscuous mode
 541:xboot.c       ****                                                         I2C_DEVICE.SLAVE.CTRLA = TWI_SLAVE_ENABLE_b
 542:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_PROMISC
 543:xboot.c       ****                                                         
 544:xboot.c       ****                                                         // we're done here
 545:xboot.c       ****                                                         goto autoneg_done;
 546:xboot.c       ****                                                 }
 547:xboot.c       ****                                                 // Check for sync command
 548:xboot.c       ****                                                 else if (val == 0x1b)
 549:xboot.c       ****                                                 {
 550:xboot.c       ****                                                         // break out to main bootloader on sync
 551:xboot.c       ****                                                         goto autoneg_done;
 552:xboot.c       ****                                                 }
 553:xboot.c       ****                                         }
 554:xboot.c       ****                                 }
 555:xboot.c       ****                                 // Already wrote normal bit, so write the inverted one
 556:xboot.c       ****                                 ow_slave_write_bit(~k & 1); // write inverted bit
 557:xboot.c       ****                                 // Now read master's guess
 558:xboot.c       ****                                 i = ow_slave_read_bit();
 559:xboot.c       ****                                 // Does the guess agree with the current bit?
 560:xboot.c       ****                                 if ((k & 1 && i) || (~k & 1 && !i))
 561:xboot.c       ****                                 {
 562:xboot.c       ****                                         // look at next bit
 563:xboot.c       ****                                         devid_bit++;
 564:xboot.c       ****                                         k >>= 1;
 565:xboot.c       ****                                         
 566:xboot.c       ****                                         // time for next byte?
 567:xboot.c       ****                                         if (!(devid_bit & 7))
 568:xboot.c       ****                                         {
 569:xboot.c       ****                                                 // Out of bits?
 570:xboot.c       ****                                                 if (devid_bit > (0x15 << 3))
 571:xboot.c       ****                                                 {
 572:xboot.c       ****                                                         // Can't break here (need to wait
 573:xboot.c       ****                                                         // to see if the master sends along
 574:xboot.c       ****                                                         // an address) so wrap around instead
 575:xboot.c       ****                                                         devid_bit = 0x08 << 3;
 576:xboot.c       ****                                                 }
 577:xboot.c       ****                                                 // there are some holes in the signature row,
 578:xboot.c       ****                                                 // so skip over them
 579:xboot.c       ****                                                 if (devid_bit == (0x0E << 3))
 580:xboot.c       ****                                                         devid_bit += 0x02 << 3;
 581:xboot.c       ****                                                 if (devid_bit == (0x11 << 3))
 582:xboot.c       ****                                                         devid_bit += 0x01 << 3;
 583:xboot.c       ****                                                 // Read next byte
 584:xboot.c       ****                                                 k = SP_ReadCalibrationByte(k >> 3);
 585:xboot.c       ****                                         }
 586:xboot.c       ****                                 }
 587:xboot.c       ****                                 else
 588:xboot.c       ****                                 {
 589:xboot.c       ****                                         // No match, we're done here
 590:xboot.c       ****                                         break;
 591:xboot.c       ****                                 }
 592:xboot.c       ****                         }
 593:xboot.c       ****                         
 594:xboot.c       **** autoneg_done:
 595:xboot.c       ****                         // dummy to avoid error message
 596:xboot.c       ****                         // this actually produces code 4 bytes smaller than either
 597:xboot.c       ****                         // an asm nop, a continue, or a bare semicolon
 598:xboot.c       ****                         i = 0;
 599:xboot.c       ****                         
 600:xboot.c       ****                         #endif
 601:xboot.c       ****                 }
 602:xboot.c       ****                 // out-of-order autonegotiate address message
 603:xboot.c       ****                 else if (val == '#')
 604:xboot.c       ****                 {
 605:xboot.c       ****                         // ignore it
 606:xboot.c       ****                         // (blocking to send a ? will cause trouble)
 607:xboot.c       ****                 }
 608:xboot.c       ****                 #endif // USE_I2C_ADDRESS_NEGOTIATION
 609:xboot.c       ****                 #endif // USE_I2C
 610:xboot.c       ****                 // ESC (0x1b) to sync
 611:xboot.c       ****                 // otherwise, error
 612:xboot.c       ****                 else if (val != 0x1b)
 613:xboot.c       ****                 {
 614:xboot.c       ****                         send_char('?');
 615:xboot.c       ****                 }
 616:xboot.c       ****         }
 617:xboot.c       ****         
 618:xboot.c       ****         #ifdef NEED_INTERRUPTS
 619:xboot.c       ****         // Disable interrupts
 620:xboot.c       ****         cli();
 621:xboot.c       ****         #endif // NEED_INTERRUPTS
 622:xboot.c       ****         
 623:xboot.c       ****         // Wait for any lingering SPM instructions to finish
 624:xboot.c       ****         SP_WaitForSPM();
 625:xboot.c       ****         
 626:xboot.c       ****         // Bootloader exit section
 627:xboot.c       ****         // Code here runs after the bootloader has exited,
 628:xboot.c       ****         // but before the application code has started
 629:xboot.c       ****         // --------------------------------------------------
 630:xboot.c       ****         
 631:xboot.c       ****         #ifdef LOCK_SPM_ON_EXIT
 632:xboot.c       ****         // Lock SPM writes
 633:xboot.c       ****         SP_LockSPM();
 634:xboot.c       ****         #endif // LOCK_SPM_ON_EXIT
 635:xboot.c       ****         
 636:xboot.c       ****         #ifdef USE_LED
 637:xboot.c       ****         // Turn off LED on exit
 638:xboot.c       ****         LED_PORT.DIRCLR = (1 << LED_PIN);
 639:xboot.c       ****         #endif // USE_LED
 640:xboot.c       ****         
 641:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 642:xboot.c       ****         #ifdef USE_ATTACH_LED
 643:xboot.c       ****         // Disable ATTACH_LED
 644:xboot.c       ****         ATTACH_LED_PORT.DIRCLR = (1 << ATTACH_LED_PIN);
 645:xboot.c       ****         #endif // USE_ATTACH_LED
 646:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 647:xboot.c       ****         
 648:xboot.c       ****         #ifdef NEED_INTERRUPTS
 649:xboot.c       ****         // remap interrupts back to application section
 650:xboot.c       ****         CCP = CCP_IOREG_gc;
 651:xboot.c       ****         PMIC.CTRL = 0;
 652:xboot.c       ****         #endif // NEED_INTERRUPTS
 653:xboot.c       **** 
 654:xboot.c       ****         #ifdef USE_WATCHDOG
 655:xboot.c       ****         WDT_Disable();
 656:xboot.c       ****         #endif // USE_WATCHDOG
 657:xboot.c       ****         
 658:xboot.c       ****         // --------------------------------------------------
 659:xboot.c       ****         // End bootloader exit section
 660:xboot.c       ****         
 661:xboot.c       ****         // Jump into main code
 662:xboot.c       ****         EIND = 0x00;
 663:xboot.c       ****         reset_vect();
 664:xboot.c       **** }
 665:xboot.c       **** 
 666:xboot.c       **** #ifdef USE_I2C_ADDRESS_NEGOTIATION
 667:xboot.c       **** 
 668:xboot.c       **** #ifdef __AVR_XMEGA__
 669:xboot.c       **** #define ow_assert()             I2C_AUTONEG_PORT.DIRSET = (1 << I2C_AUTONEG_PIN)
 670:xboot.c       **** #define ow_deassert()           I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN)
 671:xboot.c       **** #define ow_read()               (I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN))
 672:xboot.c       **** #define ow_is_asserted()        (!ow_read())
 673:xboot.c       **** #else
 674:xboot.c       **** #define ow_assert()             DDRC |= (1 << 0)
 675:xboot.c       **** #define ow_deassert()           DDRC &= ~(1 << 0)
 676:xboot.c       **** #define ow_read()               (PINC & (1 << 0))
 677:xboot.c       **** #define ow_is_asserted()        (!ow_read())
 678:xboot.c       **** #endif // __AVR_XMEGA__
 679:xboot.c       **** 
 680:xboot.c       **** unsigned char __attribute__ ((noinline)) ow_slave_read_bit(void)
 681:xboot.c       **** {
 682:xboot.c       ****         unsigned char ret;
 683:xboot.c       ****         ow_slave_wait_bit();
 684:xboot.c       ****         _delay_us(12);
 685:xboot.c       ****         ret = ow_read();
 686:xboot.c       ****         _delay_us(8);
 687:xboot.c       ****         return ret;
 688:xboot.c       **** }
 689:xboot.c       **** 
 690:xboot.c       **** void __attribute__ ((noinline)) ow_slave_write_bit(unsigned char b)
 691:xboot.c       **** {
 692:xboot.c       ****         ow_slave_wait_bit();
 693:xboot.c       ****         if (!b)
 694:xboot.c       ****         {
 695:xboot.c       ****                 ow_assert();
 696:xboot.c       ****         }
 697:xboot.c       ****         _delay_us(20);
 698:xboot.c       ****         ow_deassert();
 699:xboot.c       **** }
 700:xboot.c       **** 
 701:xboot.c       **** void ow_slave_wait_bit(void)
 702:xboot.c       **** {
 703:xboot.c       ****         while (ow_read()) { };
 704:xboot.c       **** }
 705:xboot.c       **** 
 706:xboot.c       **** #endif // USE_I2C_ADDRESS_NEGOTIATION
 707:xboot.c       **** 
 708:xboot.c       **** #ifdef USE_INTERRUPTS
 709:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
 710:xboot.c       **** {
 711:xboot.c       ****         unsigned char ret;
 712:xboot.c       ****         
 713:xboot.c       ****         while (rx_char_cnt == 0) { };
 714:xboot.c       ****         
 715:xboot.c       ****         cli();
 716:xboot.c       ****         
 717:xboot.c       ****         ret = rx_buff0;
 718:xboot.c       ****         rx_buff0 = rx_buff1;
 719:xboot.c       ****         rx_char_cnt--;
 720:xboot.c       ****         
 721:xboot.c       ****         sei();
 722:xboot.c       ****         
 723:xboot.c       ****         return ret;
 724:xboot.c       **** }
 725:xboot.c       **** 
 726:xboot.c       **** void __attribute__ ((noinline)) send_char(unsigned char c)
 727:xboot.c       **** {
 728:xboot.c       ****         while (1)
 729:xboot.c       ****         {
 730:xboot.c       ****                 cli();
 731:xboot.c       ****                 
 732:xboot.c       ****                 if (tx_char_cnt == 0)
 733:xboot.c       ****                 {
 734:xboot.c       ****                         tx_buff0 = c;
 735:xboot.c       ****                         tx_char_cnt = 1;
 736:xboot.c       ****                         #ifdef USE_UART
 737:xboot.c       ****                         if (comm_mode == MODE_UART)
 738:xboot.c       ****                         {
 739:xboot.c       ****                                 uart_send_char(c);
 740:xboot.c       ****                         }
 741:xboot.c       ****                         #endif // USE_UART
 742:xboot.c       ****                         sei();
 743:xboot.c       ****                         return;
 744:xboot.c       ****                 }
 745:xboot.c       ****                 
 746:xboot.c       ****                 sei();
 747:xboot.c       ****         }
 748:xboot.c       **** }
 749:xboot.c       **** 
 750:xboot.c       **** #else
 751:xboot.c       **** 
 752:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
 753:xboot.c       **** {
 401               	.LM0:
 402               	.LFBB1:
 403               	/* prologue: function */
 404               	/* frame size = 0 */
 754:xboot.c       ****         unsigned char ret;
 755:xboot.c       ****         
 756:xboot.c       ****         while (1)
 757:xboot.c       ****         {
 758:xboot.c       ****                 #ifdef USE_UART
 759:xboot.c       ****                 // Get next character
 760:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
 406               	.LM1:
 407 0000 9091 0000 		lds r25,comm_mode
 408               	.L3:
 409 0004 9230      		cpi r25,lo8(2)
 410 0006 00F4      		brsh .L2
 761:xboot.c       ****                 {
 762:xboot.c       ****                         #ifdef __AVR_XMEGA__
 763:xboot.c       ****                         if (uart_char_received())
 412               	.LM2:
 413 0008 8091 B108 		lds r24,2225
 414 000c 87FF      		sbrs r24,7
 415 000e 00C0      		rjmp .L3
 764:xboot.c       ****                         {
 765:xboot.c       ****                                 comm_mode = MODE_UART;
 417               	.LM3:
 418 0010 81E0      		ldi r24,lo8(1)
 419 0012 8093 0000 		sts comm_mode,r24
 766:xboot.c       ****                                 return uart_cur_char();
 421               	.LM4:
 422 0016 8091 B008 		lds r24,2224
 423               	/* epilogue start */
 767:xboot.c       ****                         }
 768:xboot.c       ****                         #endif // __AVR_XMEGA__
 769:xboot.c       ****                 }
 770:xboot.c       ****                 #endif // USE_UART
 771:xboot.c       ****                 
 772:xboot.c       ****                 #ifdef USE_I2C
 773:xboot.c       ****                 // Get next character
 774:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
 775:xboot.c       ****                 {
 776:xboot.c       ****                         #ifdef __AVR_XMEGA__
 777:xboot.c       ****                         if (i2c_address_match())
 778:xboot.c       ****                         {
 779:xboot.c       ****                                 // Address match, send ACK
 780:xboot.c       ****                                 i2c_send_ack();
 781:xboot.c       ****                                 comm_mode = MODE_I2C;
 782:xboot.c       ****                                 first_byte = 1;
 783:xboot.c       ****                         }
 784:xboot.c       ****                         if (i2c_char_received())
 785:xboot.c       ****                         {
 786:xboot.c       ****                                 // Data has arrived
 787:xboot.c       ****                                 ret = i2c_cur_char();
 788:xboot.c       ****                                 i2c_send_ack();
 789:xboot.c       ****                                 return ret;
 790:xboot.c       ****                         }
 791:xboot.c       ****                         if (i2c_ready_data())
 792:xboot.c       ****                         {
 793:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
 794:xboot.c       ****                                 {
 795:xboot.c       ****                                         i2c_end_transmission(); // end transaction
 796:xboot.c       ****                                 }
 797:xboot.c       ****                                 else
 798:xboot.c       ****                                 {
 799:xboot.c       ****                                         first_byte = 0;
 800:xboot.c       ****                                         // Wants data, but there is no data to send...
 801:xboot.c       ****                                         // also include NAK
 802:xboot.c       ****                                         i2c_send_char('?');
 803:xboot.c       ****                                         i2c_send_nak();
 804:xboot.c       ****                                 }
 805:xboot.c       ****                         }
 806:xboot.c       ****                         #endif // __AVR_XMEGA__
 807:xboot.c       ****                 }
 808:xboot.c       ****                 #endif // USE_I2C
 809:xboot.c       ****         }
 810:xboot.c       ****         
 811:xboot.c       ****         return ret;
 812:xboot.c       **** }
 425               	.LM5:
 426 001a 0895      		ret
 427               	.L2:
 428               	.L6:
 429 001c 00C0      		rjmp .L6
 431               	.Lscope1:
 434               	.global	send_char
 436               	send_char:
 813:xboot.c       **** 
 814:xboot.c       **** void __attribute__ ((noinline)) send_char(unsigned char c)
 815:xboot.c       **** {
 438               	.LM6:
 439               	.LFBB2:
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442 001e 982F      		mov r25,r24
 816:xboot.c       ****         #ifdef USE_I2C
 817:xboot.c       ****         unsigned char tmp;
 818:xboot.c       ****         #endif
 819:xboot.c       ****         
 820:xboot.c       ****         #ifdef USE_UART
 821:xboot.c       ****         // Send character
 822:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
 444               	.LM7:
 445 0020 8091 0000 		lds r24,comm_mode
 446 0024 8230      		cpi r24,lo8(2)
 447 0026 00F4      		brsh .L10
 823:xboot.c       ****         {
 824:xboot.c       ****                 #ifdef __AVR_XMEGA__
 825:xboot.c       ****                 uart_send_char_blocking(c);
 449               	.LM8:
 450 0028 9093 B008 		sts 2224,r25
 451               	.L9:
 452 002c 8091 B108 		lds r24,2225
 453 0030 86FF      		sbrs r24,6
 454 0032 00C0      		rjmp .L9
 455 0034 8091 B108 		lds r24,2225
 456 0038 8064      		ori r24,lo8(64)
 457 003a E0EB      		ldi r30,lo8(2224)
 458 003c F8E0      		ldi r31,hi8(2224)
 459 003e 8183      		std Z+1,r24
 460               	.L10:
 461 0040 0895      		ret
 463               	.Lscope2:
 468               	.global	BlockRead
 470               	BlockRead:
 826:xboot.c       ****                 #endif // __AVR_XMEGA__
 827:xboot.c       ****                 
 828:xboot.c       ****         }
 829:xboot.c       ****         #endif // USE_UART
 830:xboot.c       ****         
 831:xboot.c       ****         #ifdef USE_I2C
 832:xboot.c       ****         // Send character
 833:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
 834:xboot.c       ****         {
 835:xboot.c       ****                 while (1)
 836:xboot.c       ****                 {
 837:xboot.c       ****                         #ifdef __AVR_XMEGA__
 838:xboot.c       ****                         if (i2c_address_match())
 839:xboot.c       ****                         {
 840:xboot.c       ****                                 // Address match, send ACK
 841:xboot.c       ****                                 i2c_send_ack();
 842:xboot.c       ****                                 first_byte = 1;
 843:xboot.c       ****                         }
 844:xboot.c       ****                         if (i2c_char_received())
 845:xboot.c       ****                         {
 846:xboot.c       ****                                 // Data has arrived, ignore it
 847:xboot.c       ****                                 tmp = i2c_cur_char();
 848:xboot.c       ****                                 i2c_send_ack();
 849:xboot.c       ****                         }
 850:xboot.c       ****                         if (i2c_ready_data())
 851:xboot.c       ****                         {
 852:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
 853:xboot.c       ****                                 {
 854:xboot.c       ****                                         i2c_end_transmission(); // end transaction
 855:xboot.c       ****                                 }
 856:xboot.c       ****                                 else
 857:xboot.c       ****                                 {
 858:xboot.c       ****                                         first_byte = 0;
 859:xboot.c       ****                                         // Send data along
 860:xboot.c       ****                                         i2c_send_char(c);
 861:xboot.c       ****                                         i2c_send_ack();
 862:xboot.c       ****                                 }
 863:xboot.c       ****                                 return;
 864:xboot.c       ****                         }
 865:xboot.c       ****                         #endif // __AVR_XMEGA__
 866:xboot.c       ****                 }
 867:xboot.c       ****         }
 868:xboot.c       ****         #endif // USE_I2C
 869:xboot.c       **** }
 870:xboot.c       **** 
 871:xboot.c       **** #endif // USE_INTERRUPTS
 872:xboot.c       **** 
 873:xboot.c       **** unsigned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T *address)
 874:xboot.c       **** {
 875:xboot.c       ****         unsigned int data;
 876:xboot.c       ****         ADDR_T tempaddress;
 877:xboot.c       ****         
 878:xboot.c       **** 	#ifdef USE_WATCHDOG
 879:xboot.c       **** 	WDT_Reset();
 880:xboot.c       **** 	#endif // USE_WATCHDOG
 881:xboot.c       **** 
 882:xboot.c       ****         // EEPROM memory type.
 883:xboot.c       ****         if(mem == 'E')
 884:xboot.c       ****         {
 885:xboot.c       ****                 unsigned char pageAddr, byteAddr, value;
 886:xboot.c       ****                 unsigned char buffer[APP_SECTION_PAGE_SIZE];
 887:xboot.c       ****                 
 888:xboot.c       ****                 EEPROM_FlushBuffer();
 889:xboot.c       ****                 // disable mapping of EEPROM into data space (enable IO mapped access)
 890:xboot.c       ****                 EEPROM_DisableMapping();
 891:xboot.c       ****                 
 892:xboot.c       ****                 // Fill buffer first, as EEPROM is too slow to copy with UART speed 
 893:xboot.c       ****                 for(tempaddress=0;tempaddress<size;tempaddress++){
 894:xboot.c       ****                         buffer[tempaddress] = get_char();
 895:xboot.c       ****                 }
 896:xboot.c       ****                 
 897:xboot.c       ****                 // Then program the EEPROM
 898:xboot.c       ****                 for( tempaddress=0; tempaddress < size; tempaddress++)
 899:xboot.c       ****                 {
 900:xboot.c       ****                         // void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value
 901:xboot.c       ****                         pageAddr = (unsigned char)( (*address) / EEPROM_PAGE_SIZE);
 902:xboot.c       ****                         byteAddr = (unsigned char)( (*address) & EEPROM_BYTE_ADDRESS_MASK);
 903:xboot.c       ****                         value = buffer[tempaddress];
 904:xboot.c       ****                         
 905:xboot.c       ****                         EEPROM_WriteByte(pageAddr, byteAddr, value);
 906:xboot.c       ****                         
 907:xboot.c       ****                         (*address)++; // Select next EEPROM byte
 908:xboot.c       ****                 }
 909:xboot.c       ****                 
 910:xboot.c       ****                 return '\r'; // Report programming OK
 911:xboot.c       ****         } 
 912:xboot.c       ****         
 913:xboot.c       ****         // Flash memory type
 914:xboot.c       ****         else if (mem == 'F' || mem == 'U')
 915:xboot.c       ****         {
 916:xboot.c       ****                 // NOTE: For flash programming, 'address' is given in words.
 917:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
 918:xboot.c       ****                 tempaddress = (*address);  // Store address in page.
 919:xboot.c       ****                 
 920:xboot.c       ****                 do
 921:xboot.c       ****                 {
 922:xboot.c       ****                         data = get_char();
 923:xboot.c       ****                         data |= (get_char() << 8);
 924:xboot.c       ****                         SP_LoadFlashWord(*address, data);
 925:xboot.c       ****                         (*address)+=2; // Select next word in memory.
 926:xboot.c       ****                         size -= 2; // Reduce number of bytes to write by two.
 927:xboot.c       ****                 } while(size); // Loop until all bytes written.
 928:xboot.c       ****                 
 929:xboot.c       ****                 if (mem == 'F')
 930:xboot.c       ****                 {
 931:xboot.c       ****                         SP_WriteApplicationPage(tempaddress);
 932:xboot.c       ****                 }
 933:xboot.c       ****                 else if (mem == 'U')
 934:xboot.c       ****                 {
 935:xboot.c       ****                         SP_EraseUserSignatureRow();
 936:xboot.c       ****                         SP_WaitForSPM();
 937:xboot.c       ****                         SP_WriteUserSignatureRow();
 938:xboot.c       ****                 }
 939:xboot.c       ****                 
 940:xboot.c       ****                 SP_WaitForSPM();
 941:xboot.c       ****                 
 942:xboot.c       ****                 (*address) >>= 1; // Convert address back to Flash words again.
 943:xboot.c       ****                 return '\r'; // Report programming OK
 944:xboot.c       ****         }
 945:xboot.c       **** 
 946:xboot.c       ****         // Invalid memory type?
 947:xboot.c       ****         else
 948:xboot.c       ****         {
 949:xboot.c       ****                 return '?';
 950:xboot.c       ****         }
 951:xboot.c       **** }
 952:xboot.c       **** 
 953:xboot.c       **** 
 954:xboot.c       **** 
 955:xboot.c       **** void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address)
 956:xboot.c       **** {
 472               	.LM9:
 473               	.LFBB3:
 474 0042 EF92      		push r14
 475 0044 FF92      		push r15
 476 0046 1F93      		push r17
 477 0048 CF93      		push r28
 478 004a DF93      		push r29
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481 004c 7C01      		movw r14,r24
 482 004e 162F      		mov r17,r22
 483 0050 EA01      		movw r28,r20
 957:xboot.c       ****         // EEPROM memory type.
 958:xboot.c       ****         
 959:xboot.c       ****         if (mem == 'E') // Read EEPROM
 485               	.LM10:
 486 0052 6534      		cpi r22,lo8(69)
 487 0054 01F4      		brne .L13
 488               	.LBB2:
 960:xboot.c       ****         {
 961:xboot.c       ****                 unsigned char byteAddr, pageAddr;
 962:xboot.c       ****                 
 963:xboot.c       ****                 EEPROM_DisableMapping();
 490               	.LM11:
 491 0056 8091 CC01 		lds r24,460
 492 005a 877F      		andi r24,lo8(-9)
 493 005c E0EC      		ldi r30,lo8(448)
 494 005e F1E0      		ldi r31,hi8(448)
 495 0060 8487      		std Z+12,r24
 964:xboot.c       ****                 EEPROM_FlushBuffer();
 497               	.LM12:
 498 0062 0E94 0000 		call EEPROM_FlushBuffer
 499               	.L14:
 965:xboot.c       ****                 
 966:xboot.c       ****                 do
 967:xboot.c       ****                 {
 968:xboot.c       ****                         pageAddr = (unsigned char)(*address / EEPROM_PAGE_SIZE);
 501               	.LM13:
 502 0066 8881      		ld r24,Y
 503 0068 9981      		ldd r25,Y+1
 504 006a AA81      		ldd r26,Y+2
 505 006c BB81      		ldd r27,Y+3
 969:xboot.c       ****                         byteAddr = (unsigned char)(*address & EEPROM_BYTE_ADDRESS_MASK);
 970:xboot.c       ****                         
 971:xboot.c       ****                         send_char( EEPROM_ReadByte( pageAddr, byteAddr ) );
 507               	.LM14:
 508 006e 682F      		mov r22,r24
 509 0070 6F71      		andi r22,lo8(31)
 510 0072 45E0      		ldi r20,5
 511 0074 B695      	1:	lsr r27
 512 0076 A795      		ror r26
 513 0078 9795      		ror r25
 514 007a 8795      		ror r24
 515 007c 4A95      		dec r20
 516 007e 01F4      		brne 1b
 517 0080 0E94 0000 		call EEPROM_ReadByte
 518 0084 0E94 0000 		call send_char
 972:xboot.c       ****                         // Select next EEPROM byte
 973:xboot.c       ****                         (*address)++;
 520               	.LM15:
 521 0088 8881      		ld r24,Y
 522 008a 9981      		ldd r25,Y+1
 523 008c AA81      		ldd r26,Y+2
 524 008e BB81      		ldd r27,Y+3
 525 0090 0196      		adiw r24,1
 526 0092 A11D      		adc r26,__zero_reg__
 527 0094 B11D      		adc r27,__zero_reg__
 528 0096 8883      		st Y,r24
 529 0098 9983      		std Y+1,r25
 530 009a AA83      		std Y+2,r26
 531 009c BB83      		std Y+3,r27
 974:xboot.c       ****                         size--; // Decrease number of bytes to read
 533               	.LM16:
 534 009e 0894      		sec
 535 00a0 E108      		sbc r14,__zero_reg__
 536 00a2 F108      		sbc r15,__zero_reg__
 975:xboot.c       ****                 } while (size); // Repeat until all block has been read
 538               	.LM17:
 539 00a4 E114      		cp r14,__zero_reg__
 540 00a6 F104      		cpc r15,__zero_reg__
 541 00a8 01F4      		brne .L14
 542 00aa 00C0      		rjmp .L21
 543               	.L13:
 544               	.LBE2:
 976:xboot.c       ****         }
 977:xboot.c       ****         
 978:xboot.c       ****         // Flash memory type.
 979:xboot.c       ****         else if (mem == 'F' || mem == 'U' || mem == 'P')
 546               	.LM18:
 547 00ac 6634      		cpi r22,lo8(70)
 548 00ae 01F0      		breq .L16
 549 00b0 6535      		cpi r22,lo8(85)
 550 00b2 01F0      		breq .L16
 551 00b4 6035      		cpi r22,lo8(80)
 552 00b6 01F0      		breq .+2
 553 00b8 00C0      		rjmp .L21
 554               	.L16:
 980:xboot.c       ****         {
 981:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
 556               	.LM19:
 557 00ba 8881      		ld r24,Y
 558 00bc 9981      		ldd r25,Y+1
 559 00be AA81      		ldd r26,Y+2
 560 00c0 BB81      		ldd r27,Y+3
 561 00c2 880F      		lsl r24
 562 00c4 991F      		rol r25
 563 00c6 AA1F      		rol r26
 564 00c8 BB1F      		rol r27
 565 00ca 8883      		st Y,r24
 566 00cc 9983      		std Y+1,r25
 567 00ce AA83      		std Y+2,r26
 568 00d0 BB83      		std Y+3,r27
 569               	.L20:
 982:xboot.c       ****                 
 983:xboot.c       ****                 do
 984:xboot.c       ****                 {
 985:xboot.c       ****                         if (mem == 'F')
 571               	.LM20:
 572 00d2 1634      		cpi r17,lo8(70)
 573 00d4 01F4      		brne .L17
 986:xboot.c       ****                         {
 987:xboot.c       ****                                 send_char( SP_ReadByte( *address) );
 575               	.LM21:
 576 00d6 6881      		ld r22,Y
 577 00d8 7981      		ldd r23,Y+1
 578 00da 8A81      		ldd r24,Y+2
 579 00dc 9B81      		ldd r25,Y+3
 580 00de 0E94 0000 		call SP_ReadByte
 581 00e2 0E94 0000 		call send_char
 988:xboot.c       ****                                 send_char( SP_ReadByte( (*address)+1) );
 583               	.LM22:
 584 00e6 6881      		ld r22,Y
 585 00e8 7981      		ldd r23,Y+1
 586 00ea 8A81      		ldd r24,Y+2
 587 00ec 9B81      		ldd r25,Y+3
 588 00ee 6F5F      		subi r22,lo8(-(1))
 589 00f0 7F4F      		sbci r23,hi8(-(1))
 590 00f2 8F4F      		sbci r24,hlo8(-(1))
 591 00f4 9F4F      		sbci r25,hhi8(-(1))
 592 00f6 0E94 0000 		call SP_ReadByte
 593 00fa 00C0      		rjmp .L24
 594               	.L17:
 989:xboot.c       ****                         }
 990:xboot.c       ****                         else if (mem == 'U')
 596               	.LM23:
 597 00fc 1535      		cpi r17,lo8(85)
 598 00fe 01F4      		brne .L19
 991:xboot.c       ****                         {
 992:xboot.c       ****                                 send_char( SP_ReadUserSignatureByte( *address) );
 600               	.LM24:
 601 0100 8881      		ld r24,Y
 602 0102 9981      		ldd r25,Y+1
 603 0104 0E94 0000 		call SP_ReadUserSignatureByte
 604 0108 0E94 0000 		call send_char
 993:xboot.c       ****                                 send_char( SP_ReadUserSignatureByte( (*address)+1) );
 606               	.LM25:
 607 010c 8881      		ld r24,Y
 608 010e 9981      		ldd r25,Y+1
 609 0110 0196      		adiw r24,1
 610 0112 0E94 0000 		call SP_ReadUserSignatureByte
 611 0116 00C0      		rjmp .L24
 612               	.L19:
 994:xboot.c       ****                         }
 995:xboot.c       ****                         else if (mem == 'P')
 614               	.LM26:
 615 0118 1035      		cpi r17,lo8(80)
 616 011a 01F4      		brne .L18
 996:xboot.c       ****                         {
 997:xboot.c       ****                                 send_char( SP_ReadCalibrationByte( *address) );
 618               	.LM27:
 619 011c 8881      		ld r24,Y
 620 011e 0E94 0000 		call SP_ReadCalibrationByte
 621 0122 0E94 0000 		call send_char
 998:xboot.c       ****                                 send_char( SP_ReadCalibrationByte( (*address)+1) );
 623               	.LM28:
 624 0126 8881      		ld r24,Y
 625 0128 8F5F      		subi r24,lo8(-(1))
 626 012a 0E94 0000 		call SP_ReadCalibrationByte
 627               	.L24:
 628 012e 0E94 0000 		call send_char
 629               	.L18:
 999:xboot.c       ****                         }
1000:xboot.c       ****                         
1001:xboot.c       ****                         SP_WaitForSPM();
 631               	.LM29:
 632 0132 0E94 0000 		call SP_WaitForSPM
1002:xboot.c       ****                         
1003:xboot.c       ****                         (*address) += 2;    // Select next word in memory.
 634               	.LM30:
 635 0136 8881      		ld r24,Y
 636 0138 9981      		ldd r25,Y+1
 637 013a AA81      		ldd r26,Y+2
 638 013c BB81      		ldd r27,Y+3
 639 013e 0296      		adiw r24,2
 640 0140 A11D      		adc r26,__zero_reg__
 641 0142 B11D      		adc r27,__zero_reg__
 642 0144 8883      		st Y,r24
 643 0146 9983      		std Y+1,r25
 644 0148 AA83      		std Y+2,r26
 645 014a BB83      		std Y+3,r27
1004:xboot.c       ****                         size -= 2;          // Subtract two bytes from number of bytes to read
 647               	.LM31:
 648 014c 2EEF      		ldi r18,lo8(-2)
 649 014e 3FEF      		ldi r19,hi8(-2)
 650 0150 E20E      		add r14,r18
 651 0152 F31E      		adc r15,r19
1005:xboot.c       ****                 } while (size);         // Repeat until all block has been read
 653               	.LM32:
 654 0154 E114      		cp r14,__zero_reg__
 655 0156 F104      		cpc r15,__zero_reg__
 656 0158 01F0      		breq .+2
 657 015a 00C0      		rjmp .L20
1006:xboot.c       ****                 
1007:xboot.c       ****                 (*address) >>= 1;       // Convert address back to Flash words again.
 659               	.LM33:
 660 015c B695      		lsr r27
 661 015e A795      		ror r26
 662 0160 9795      		ror r25
 663 0162 8795      		ror r24
 664 0164 8883      		st Y,r24
 665 0166 9983      		std Y+1,r25
 666 0168 AA83      		std Y+2,r26
 667 016a BB83      		std Y+3,r27
 668               	.L21:
 669               	/* epilogue start */
1008:xboot.c       ****         }
1009:xboot.c       **** }
 671               	.LM34:
 672 016c DF91      		pop r29
 673 016e CF91      		pop r28
 674 0170 1F91      		pop r17
 675 0172 FF90      		pop r15
 676 0174 EF90      		pop r14
 677 0176 0895      		ret
 679               	.Lscope3:
 684               	.global	BlockLoad
 686               	BlockLoad:
 875:xboot.c       **** {
 688               	.LM35:
 689               	.LFBB4:
 690 0178 5F92      		push r5
 691 017a 6F92      		push r6
 692 017c 7F92      		push r7
 693 017e 8F92      		push r8
 694 0180 9F92      		push r9
 695 0182 AF92      		push r10
 696 0184 BF92      		push r11
 697 0186 CF92      		push r12
 698 0188 DF92      		push r13
 699 018a EF92      		push r14
 700 018c FF92      		push r15
 701 018e 0F93      		push r16
 702 0190 1F93      		push r17
 703 0192 DF93      		push r29
 704 0194 CF93      		push r28
 705 0196 CDB7      		in r28,__SP_L__
 706 0198 DEB7      		in r29,__SP_H__
 707 019a C050      		subi r28,lo8(-(-512))
 708 019c D240      		sbci r29,hi8(-(-512))
 709 019e CDBF      		out __SP_L__,r28
 710 01a0 DEBF      		out __SP_H__,r29
 711               	/* prologue: function */
 712               	/* frame size = 512 */
 713 01a2 3C01      		movw r6,r24
 714 01a4 562E      		mov r5,r22
 715 01a6 4A01      		movw r8,r20
 884:xboot.c       ****         if(mem == 'E')
 717               	.LM36:
 718 01a8 85E4      		ldi r24,lo8(69)
 719 01aa 6817      		cp r22,r24
 720 01ac 01F4      		brne .L26
 721               	.LBB3:
 889:xboot.c       ****                 EEPROM_FlushBuffer();
 723               	.LM37:
 724 01ae 0E94 0000 		call EEPROM_FlushBuffer
 891:xboot.c       ****                 EEPROM_DisableMapping();
 726               	.LM38:
 727 01b2 8091 CC01 		lds r24,460
 728 01b6 877F      		andi r24,lo8(-9)
 729 01b8 E0EC      		ldi r30,lo8(448)
 730 01ba F1E0      		ldi r31,hi8(448)
 731 01bc 8487      		std Z+12,r24
 732 01be 7E01      		movw r14,r28
 733 01c0 0894      		sec
 734 01c2 E11C      		adc r14,__zero_reg__
 735 01c4 F11C      		adc r15,__zero_reg__
 736 01c6 6701      		movw r12,r14
 894:xboot.c       ****                 for(tempaddress=0;tempaddress<size;tempaddress++){
 738               	.LM39:
 739 01c8 5701      		movw r10,r14
 740 01ca A60C      		add r10,r6
 741 01cc B71C      		adc r11,r7
 742 01ce 00C0      		rjmp .L27
 743               	.L28:
 895:xboot.c       ****                         buffer[tempaddress] = get_char();
 745               	.LM40:
 746 01d0 0E94 0000 		call get_char
 747 01d4 F601      		movw r30,r12
 748 01d6 8193      		st Z+,r24
 749 01d8 6F01      		movw r12,r30
 750               	.L27:
 894:xboot.c       ****                 for(tempaddress=0;tempaddress<size;tempaddress++){
 752               	.LM41:
 753 01da CA14      		cp r12,r10
 754 01dc DB04      		cpc r13,r11
 755 01de 01F4      		brne .L28
 756 01e0 00C0      		rjmp .L38
 757               	.L30:
 902:xboot.c       ****                         pageAddr = (unsigned char)( (*address) / EEPROM_PAGE_SIZE);
 759               	.LM42:
 760 01e2 F401      		movw r30,r8
 761 01e4 8081      		ld r24,Z
 762 01e6 9181      		ldd r25,Z+1
 763 01e8 A281      		ldd r26,Z+2
 764 01ea B381      		ldd r27,Z+3
 906:xboot.c       ****                         EEPROM_WriteByte(pageAddr, byteAddr, value);
 766               	.LM43:
 767 01ec 682F      		mov r22,r24
 768 01ee 6F71      		andi r22,lo8(31)
 769 01f0 75E0      		ldi r23,5
 770 01f2 B695      	1:	lsr r27
 771 01f4 A795      		ror r26
 772 01f6 9795      		ror r25
 773 01f8 8795      		ror r24
 774 01fa 7A95      		dec r23
 775 01fc 01F4      		brne 1b
 776 01fe F701      		movw r30,r14
 777 0200 4191      		ld r20,Z+
 778 0202 7F01      		movw r14,r30
 779 0204 0E94 0000 		call EEPROM_WriteByte
 908:xboot.c       ****                         (*address)++; // Select next EEPROM byte
 781               	.LM44:
 782 0208 F401      		movw r30,r8
 783 020a 8081      		ld r24,Z
 784 020c 9181      		ldd r25,Z+1
 785 020e A281      		ldd r26,Z+2
 786 0210 B381      		ldd r27,Z+3
 787 0212 0196      		adiw r24,1
 788 0214 A11D      		adc r26,__zero_reg__
 789 0216 B11D      		adc r27,__zero_reg__
 790 0218 8083      		st Z,r24
 791 021a 9183      		std Z+1,r25
 792 021c A283      		std Z+2,r26
 793 021e B383      		std Z+3,r27
 794               	.L38:
 899:xboot.c       ****                 for( tempaddress=0; tempaddress < size; tempaddress++)
 796               	.LM45:
 797 0220 EC14      		cp r14,r12
 798 0222 FD04      		cpc r15,r13
 799 0224 01F4      		brne .L30
 800 0226 00C0      		rjmp .L39
 801               	.L26:
 802               	.LBE3:
 915:xboot.c       ****         else if (mem == 'F' || mem == 'U')
 804               	.LM46:
 805 0228 F6E4      		ldi r31,lo8(70)
 806 022a 6F17      		cp r22,r31
 807 022c 01F0      		breq .L32
 808 022e 85E5      		ldi r24,lo8(85)
 809 0230 6817      		cp r22,r24
 810 0232 01F0      		breq .L32
 811 0234 8FE3      		ldi r24,lo8(63)
 812 0236 00C0      		rjmp .L31
 813               	.L32:
 918:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
 815               	.LM47:
 816 0238 F401      		movw r30,r8
 817 023a C080      		ld r12,Z
 818 023c D180      		ldd r13,Z+1
 819 023e E280      		ldd r14,Z+2
 820 0240 F380      		ldd r15,Z+3
 821 0242 CC0C      		lsl r12
 822 0244 DD1C      		rol r13
 823 0246 EE1C      		rol r14
 824 0248 FF1C      		rol r15
 825 024a C082      		st Z,r12
 826 024c D182      		std Z+1,r13
 827 024e E282      		std Z+2,r14
 828 0250 F382      		std Z+3,r15
 829               	.L33:
 923:xboot.c       ****                         data = get_char();
 831               	.LM48:
 832 0252 0E94 0000 		call get_char
 833 0256 082F      		mov r16,r24
 834 0258 10E0      		ldi r17,lo8(0)
 924:xboot.c       ****                         data |= (get_char() << 8);
 836               	.LM49:
 837 025a 0E94 0000 		call get_char
 925:xboot.c       ****                         SP_LoadFlashWord(*address, data);
 839               	.LM50:
 840 025e B82E      		mov r11,r24
 841 0260 AA24      		clr r10
 842 0262 0A29      		or r16,r10
 843 0264 1B29      		or r17,r11
 844 0266 F401      		movw r30,r8
 845 0268 8081      		ld r24,Z
 846 026a 9181      		ldd r25,Z+1
 847 026c B801      		movw r22,r16
 848 026e 0E94 0000 		call SP_LoadFlashWord
 926:xboot.c       ****                         (*address)+=2; // Select next word in memory.
 850               	.LM51:
 851 0272 F401      		movw r30,r8
 852 0274 8081      		ld r24,Z
 853 0276 9181      		ldd r25,Z+1
 854 0278 A281      		ldd r26,Z+2
 855 027a B381      		ldd r27,Z+3
 856 027c 0296      		adiw r24,2
 857 027e A11D      		adc r26,__zero_reg__
 858 0280 B11D      		adc r27,__zero_reg__
 859 0282 8083      		st Z,r24
 860 0284 9183      		std Z+1,r25
 861 0286 A283      		std Z+2,r26
 862 0288 B383      		std Z+3,r27
 927:xboot.c       ****                         size -= 2; // Reduce number of bytes to write by two.
 864               	.LM52:
 865 028a 8EEF      		ldi r24,lo8(-2)
 866 028c 9FEF      		ldi r25,hi8(-2)
 867 028e 680E      		add r6,r24
 868 0290 791E      		adc r7,r25
 928:xboot.c       ****                 } while(size); // Loop until all bytes written.
 870               	.LM53:
 871 0292 6114      		cp r6,__zero_reg__
 872 0294 7104      		cpc r7,__zero_reg__
 873 0296 01F4      		brne .L33
 930:xboot.c       ****                 if (mem == 'F')
 875               	.LM54:
 876 0298 96E4      		ldi r25,lo8(70)
 877 029a 5916      		cp r5,r25
 878 029c 01F4      		brne .L34
 932:xboot.c       ****                         SP_WriteApplicationPage(tempaddress);
 880               	.LM55:
 881 029e C701      		movw r24,r14
 882 02a0 B601      		movw r22,r12
 883 02a2 0E94 0000 		call SP_WriteApplicationPage
 884 02a6 00C0      		rjmp .L35
 885               	.L34:
 934:xboot.c       ****                 else if (mem == 'U')
 887               	.LM56:
 888 02a8 E5E5      		ldi r30,lo8(85)
 889 02aa 5E16      		cp r5,r30
 890 02ac 01F4      		brne .L35
 936:xboot.c       ****                         SP_EraseUserSignatureRow();
 892               	.LM57:
 893 02ae 0E94 0000 		call SP_EraseUserSignatureRow
 937:xboot.c       ****                         SP_WaitForSPM();
 895               	.LM58:
 896 02b2 0E94 0000 		call SP_WaitForSPM
 938:xboot.c       ****                         SP_WriteUserSignatureRow();
 898               	.LM59:
 899 02b6 0E94 0000 		call SP_WriteUserSignatureRow
 900               	.L35:
 941:xboot.c       ****                 SP_WaitForSPM();
 902               	.LM60:
 903 02ba 0E94 0000 		call SP_WaitForSPM
 943:xboot.c       ****                 (*address) >>= 1; // Convert address back to Flash words again.
 905               	.LM61:
 906 02be F401      		movw r30,r8
 907 02c0 8081      		ld r24,Z
 908 02c2 9181      		ldd r25,Z+1
 909 02c4 A281      		ldd r26,Z+2
 910 02c6 B381      		ldd r27,Z+3
 911 02c8 B695      		lsr r27
 912 02ca A795      		ror r26
 913 02cc 9795      		ror r25
 914 02ce 8795      		ror r24
 915 02d0 8083      		st Z,r24
 916 02d2 9183      		std Z+1,r25
 917 02d4 A283      		std Z+2,r26
 918 02d6 B383      		std Z+3,r27
 919               	.L39:
 920 02d8 8DE0      		ldi r24,lo8(13)
 921               	.L31:
 922               	/* epilogue start */
 952:xboot.c       **** }
 924               	.LM62:
 925 02da C050      		subi r28,lo8(-(512))
 926 02dc DE4F      		sbci r29,hi8(-(512))
 927 02de CDBF      		out __SP_L__,r28
 928 02e0 DEBF      		out __SP_H__,r29
 929 02e2 CF91      		pop r28
 930 02e4 DF91      		pop r29
 931 02e6 1F91      		pop r17
 932 02e8 0F91      		pop r16
 933 02ea FF90      		pop r15
 934 02ec EF90      		pop r14
 935 02ee DF90      		pop r13
 936 02f0 CF90      		pop r12
 937 02f2 BF90      		pop r11
 938 02f4 AF90      		pop r10
 939 02f6 9F90      		pop r9
 940 02f8 8F90      		pop r8
 941 02fa 7F90      		pop r7
 942 02fc 6F90      		pop r6
 943 02fe 5F90      		pop r5
 944 0300 0895      		ret
 952               	.Lscope4:
 954               	.global	main
 956               	main:
  51:xboot.c       **** {
 958               	.LM63:
 959               	.LFBB5:
 960 0302 2F92      		push r2
 961 0304 3F92      		push r3
 962 0306 4F92      		push r4
 963 0308 5F92      		push r5
 964 030a 6F92      		push r6
 965 030c 7F92      		push r7
 966 030e 8F92      		push r8
 967 0310 9F92      		push r9
 968 0312 AF92      		push r10
 969 0314 BF92      		push r11
 970 0316 CF92      		push r12
 971 0318 DF92      		push r13
 972 031a EF92      		push r14
 973 031c FF92      		push r15
 974 031e 0F93      		push r16
 975 0320 1F93      		push r17
 976 0322 DF93      		push r29
 977 0324 CF93      		push r28
 978 0326 CDB7      		in r28,__SP_L__
 979 0328 DEB7      		in r29,__SP_H__
 980 032a 2597      		sbiw r28,5
 981 032c CDBF      		out __SP_L__,r28
 982 032e DEBF      		out __SP_H__,r29
 983               	/* prologue: function */
 984               	/* frame size = 5 */
  62:xboot.c       ****         comm_mode = MODE_UNDEF;
 986               	.LM64:
 987 0330 1092 0000 		sts comm_mode,__zero_reg__
  78:xboot.c       ****         OSC.CTRL |= OSC_RC32MEN_bm; // turn on 32 MHz oscillator
 989               	.LM65:
 990 0334 8091 5000 		lds r24,80
 991 0338 8260      		ori r24,lo8(2)
 992 033a 8093 5000 		sts 80,r24
 993               	.L41:
  79:xboot.c       ****         while (!(OSC.STATUS & OSC_RC32MRDY_bm)) { }; // wait for it to start
 995               	.LM66:
 996 033e 8091 5100 		lds r24,81
 997 0342 81FF      		sbrs r24,1
 998 0344 00C0      		rjmp .L41
  80:xboot.c       ****         CCP = CCP_IOREG_gc;
 1000               	.LM67:
 1001 0346 88ED      		ldi r24,lo8(-40)
 1002 0348 84BF      		out 52-0,r24
  81:xboot.c       ****         CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
 1004               	.LM68:
 1005 034a 81E0      		ldi r24,lo8(1)
 1006 034c 8093 4000 		sts 64,r24
  83:xboot.c       ****         DFLLRC32M.CTRL = DFLL_ENABLE_bm;
 1008               	.LM69:
 1009 0350 8093 6000 		sts 96,r24
 109:xboot.c       ****         LED_PORT.DIRSET = (1 << LED_PIN);
 1011               	.LM70:
 1012 0354 E0E0      		ldi r30,lo8(1536)
 1013 0356 F6E0      		ldi r31,hi8(1536)
 1014 0358 80E8      		ldi r24,lo8(-128)
 1015 035a 8183      		std Z+1,r24
 113:xboot.c       ****         LED_PORT.OUTSET = (1 << LED_PIN);
 1017               	.LM71:
 1018 035c 8583      		std Z+5,r24
  54:xboot.c       ****         unsigned char val = 0;
 1020               	.LM72:
 1021 035e 1982      		std Y+1,__zero_reg__
  52:xboot.c       ****         ADDR_T address = 0;
 1023               	.LM73:
 1024 0360 1A82      		std Y+2,__zero_reg__
 1025 0362 1B82      		std Y+3,__zero_reg__
 1026 0364 1C82      		std Y+4,__zero_reg__
 1027 0366 1D82      		std Y+5,__zero_reg__
 140:xboot.c       ****         uart_init();
 1029               	.LM74:
 1030 0368 0E94 0000 		call uart_init
 1031 036c 20E3      		ldi r18,lo8(30000)
 1032 036e 35E7      		ldi r19,hi8(30000)
 1033 0370 48E0      		ldi r20,lo8(8)
 1034 0372 50E0      		ldi r21,hi8(8)
 175:xboot.c       ****                         LED_PORT.OUTTGL = (1 << LED_PIN);
 1036               	.LM75:
 1037 0374 E0E0      		ldi r30,lo8(1536)
 1038 0376 F6E0      		ldi r31,hi8(1536)
 1039 0378 90E8      		ldi r25,lo8(-128)
 1040               	.L46:
 172:xboot.c       ****                 if (j-- <= 0)
 1042               	.LM76:
 1043 037a 1216      		cp __zero_reg__,r18
 1044 037c 1306      		cpc __zero_reg__,r19
 1045 037e 04F4      		brge .L42
 1046 0380 2150      		subi r18,lo8(-(-1))
 1047 0382 3040      		sbci r19,hi8(-(-1))
 1048 0384 00C0      		rjmp .L43
 1049               	.L42:
 175:xboot.c       ****                         LED_PORT.OUTTGL = (1 << LED_PIN);
 1051               	.LM77:
 1052 0386 9783      		std Z+7,r25
 178:xboot.c       ****                         k--;
 1054               	.LM78:
 1055 0388 4150      		subi r20,lo8(-(-1))
 1056 038a 5040      		sbci r21,hi8(-(-1))
 1057 038c 20E3      		ldi r18,lo8(30000)
 1058 038e 35E7      		ldi r19,hi8(30000)
 1059               	.L43:
 204:xboot.c       ****                 if (uart_char_received())
 1061               	.LM79:
 1062 0390 8091 B108 		lds r24,2225
 1063 0394 87FF      		sbrs r24,7
 1064 0396 00C0      		rjmp .L44
 207:xboot.c       ****                         comm_mode = MODE_UART;
 1066               	.LM80:
 1067 0398 81E0      		ldi r24,lo8(1)
 1068 039a 8093 0000 		sts comm_mode,r24
 1069 039e 00C0      		rjmp .L84
 1070               	.L44:
 170:xboot.c       ****         while (!in_bootloader && k > 0)
 1072               	.LM81:
 1073 03a0 1416      		cp __zero_reg__,r20
 1074 03a2 1506      		cpc __zero_reg__,r21
 1075 03a4 04F0      		brlt .L46
 1076 03a6 00C0      		rjmp .L85
 1077               	.L84:
 241:xboot.c       ****                 LED_PORT.OUTTGL = (1 << LED_PIN);
 1079               	.LM82:
 1080 03a8 20E8      		ldi r18,lo8(-128)
 1081 03aa 2093 0706 		sts 1543,r18
 244:xboot.c       ****                 val = get_char();
 1083               	.LM83:
 1084 03ae 0E94 0000 		call get_char
 1085 03b2 982F      		mov r25,r24
 1086 03b4 8983      		std Y+1,r24
 252:xboot.c       ****                 if (val == 'a')
 1088               	.LM84:
 1089 03b6 8136      		cpi r24,lo8(97)
 1090 03b8 01F4      		brne .L47
 255:xboot.c       ****                         send_char('Y');
 1092               	.LM85:
 1093 03ba 89E5      		ldi r24,lo8(89)
 1094 03bc 00C0      		rjmp .L86
 1095               	.L47:
 258:xboot.c       ****                 else if (val == 'A')
 1097               	.LM86:
 1098 03be 8134      		cpi r24,lo8(65)
 1099 03c0 01F4      		brne .L48
 261:xboot.c       ****                         address = (((ADDR_T)get_char() << 8) | (ADDR_T)get_char()) & 0x0000FFFF;
 1101               	.LM87:
 1102 03c2 0E94 0000 		call get_char
 1103 03c6 E82E      		mov r14,r24
 1104 03c8 0E94 0000 		call get_char
 1105 03cc FF24      		clr r15
 1106 03ce 00E0      		ldi r16,lo8(0)
 1107 03d0 10E0      		ldi r17,hi8(0)
 1108 03d2 102F      		mov r17,r16
 1109 03d4 0F2D      		mov r16,r15
 1110 03d6 FE2C      		mov r15,r14
 1111 03d8 EE24      		clr r14
 1112 03da 00C0      		rjmp .L93
 1113               	.L48:
 266:xboot.c       ****                 else if (val == 'H')
 1115               	.LM88:
 1116 03dc 8834      		cpi r24,lo8(72)
 1117 03de 01F4      		brne .L49
 269:xboot.c       ****                         address = (((ADDR_T)get_char() << 16) | ((ADDR_T)get_char() << 8) | (ADDR_T
 1119               	.LM89:
 1120 03e0 0E94 0000 		call get_char
 1121 03e4 E82E      		mov r14,r24
 1122 03e6 0E94 0000 		call get_char
 1123 03ea A82E      		mov r10,r24
 1124 03ec 0E94 0000 		call get_char
 1125 03f0 FF24      		clr r15
 1126 03f2 00E0      		ldi r16,lo8(0)
 1127 03f4 10E0      		ldi r17,hi8(0)
 1128 03f6 8701      		movw r16,r14
 1129 03f8 FF24      		clr r15
 1130 03fa EE24      		clr r14
 1131 03fc BB24      		clr r11
 1132 03fe CC24      		clr r12
 1133 0400 DD24      		clr r13
 1134 0402 DC2C      		mov r13,r12
 1135 0404 CB2C      		mov r12,r11
 1136 0406 BA2C      		mov r11,r10
 1137 0408 AA24      		clr r10
 1138 040a EA28      		or r14,r10
 1139 040c FB28      		or r15,r11
 1140 040e 0C29      		or r16,r12
 1141 0410 1D29      		or r17,r13
 1142               	.L93:
 1143 0412 90E0      		ldi r25,lo8(0)
 1144 0414 A0E0      		ldi r26,lo8(0)
 1145 0416 B0E0      		ldi r27,hi8(0)
 1146 0418 E82A      		or r14,r24
 1147 041a F92A      		or r15,r25
 1148 041c 0A2B      		or r16,r26
 1149 041e 1B2B      		or r17,r27
 1150 0420 EA82      		std Y+2,r14
 1151 0422 FB82      		std Y+3,r15
 1152 0424 0C83      		std Y+4,r16
 1153 0426 1D83      		std Y+5,r17
 1154 0428 00C0      		rjmp .L89
 1155               	.L49:
 274:xboot.c       ****                 else if (val == 'e')
 1157               	.LM90:
 1158 042a 8536      		cpi r24,lo8(101)
 1159 042c 01F4      		brne .L50
 276:xboot.c       ****                         for (address = 0; address < APP_SECTION_SIZE; address += APP_SECTION_PAGE_S
 1161               	.LM91:
 1162 042e 1A82      		std Y+2,__zero_reg__
 1163 0430 1B82      		std Y+3,__zero_reg__
 1164 0432 1C82      		std Y+4,__zero_reg__
 1165 0434 1D82      		std Y+5,__zero_reg__
 1166 0436 00C0      		rjmp .L51
 1167               	.L52:
 282:xboot.c       ****                                 SP_WaitForSPM();
 1169               	.LM92:
 1170 0438 0E94 0000 		call SP_WaitForSPM
 284:xboot.c       ****                                 SP_EraseApplicationPage(address);
 1172               	.LM93:
 1173 043c 6A81      		ldd r22,Y+2
 1174 043e 7B81      		ldd r23,Y+3
 1175 0440 8C81      		ldd r24,Y+4
 1176 0442 9D81      		ldd r25,Y+5
 1177 0444 0E94 0000 		call SP_EraseApplicationPage
 276:xboot.c       ****                         for (address = 0; address < APP_SECTION_SIZE; address += APP_SECTION_PAGE_S
 1179               	.LM94:
 1180 0448 8A81      		ldd r24,Y+2
 1181 044a 9B81      		ldd r25,Y+3
 1182 044c AC81      		ldd r26,Y+4
 1183 044e BD81      		ldd r27,Y+5
 1184 0450 8050      		subi r24,lo8(-(512))
 1185 0452 9E4F      		sbci r25,hi8(-(512))
 1186 0454 AF4F      		sbci r26,hlo8(-(512))
 1187 0456 BF4F      		sbci r27,hhi8(-(512))
 1188 0458 8A83      		std Y+2,r24
 1189 045a 9B83      		std Y+3,r25
 1190 045c AC83      		std Y+4,r26
 1191 045e BD83      		std Y+5,r27
 1192               	.L51:
 1193 0460 8A81      		ldd r24,Y+2
 1194 0462 9B81      		ldd r25,Y+3
 1195 0464 AC81      		ldd r26,Y+4
 1196 0466 BD81      		ldd r27,Y+5
 1197 0468 8050      		subi r24,lo8(131072)
 1198 046a 9040      		sbci r25,hi8(131072)
 1199 046c A240      		sbci r26,hlo8(131072)
 1200 046e B040      		sbci r27,hhi8(131072)
 1201 0470 00F0      		brlo .L52
 288:xboot.c       ****                         EEPROM_LoadPage(&val);
 1203               	.LM95:
 1204 0472 CE01      		movw r24,r28
 1205 0474 0196      		adiw r24,1
 1206 0476 0E94 0000 		call EEPROM_LoadPage
 290:xboot.c       ****                         EEPROM_EraseAll();
 1208               	.LM96:
 1209 047a 0E94 0000 		call EEPROM_EraseAll
 1210 047e 00C0      		rjmp .L89
 1211               	.L50:
 297:xboot.c       ****                 else if (val == 'b')
 1213               	.LM97:
 1214 0480 8236      		cpi r24,lo8(98)
 1215 0482 01F4      		brne .L53
 300:xboot.c       ****                         send_char('Y');
 1217               	.LM98:
 1218 0484 89E5      		ldi r24,lo8(89)
 1219 0486 0E94 0000 		call send_char
 302:xboot.c       ****                         send_char((APP_SECTION_PAGE_SIZE >> 8) & 0xFF);
 1221               	.LM99:
 1222 048a 82E0      		ldi r24,lo8(2)
 1223 048c 00C0      		rjmp .L90
 1224               	.L53:
 306:xboot.c       ****                 else if (val == 'B')
 1226               	.LM100:
 1227 048e 8234      		cpi r24,lo8(66)
 1228 0490 01F4      		brne .L54
 309:xboot.c       ****                         i = (get_char() << 8) | get_char();
 1230               	.LM101:
 1231 0492 0E94 0000 		call get_char
 1232 0496 182F      		mov r17,r24
 1233 0498 0E94 0000 		call get_char
 1234 049c 712E      		mov r7,r17
 1235 049e 6624      		clr r6
 1236 04a0 882E      		mov r8,r24
 1237 04a2 9924      		clr r9
 1238 04a4 8628      		or r8,r6
 1239 04a6 9728      		or r9,r7
 311:xboot.c       ****                         val = get_char();
 1241               	.LM102:
 1242 04a8 0E94 0000 		call get_char
 1243 04ac 682F      		mov r22,r24
 1244 04ae 8983      		std Y+1,r24
 313:xboot.c       ****                         send_char(BlockLoad(i, val, &address));
 1246               	.LM103:
 1247 04b0 C401      		movw r24,r8
 1248 04b2 AE01      		movw r20,r28
 1249 04b4 4E5F      		subi r20,lo8(-(2))
 1250 04b6 5F4F      		sbci r21,hi8(-(2))
 1251 04b8 0E94 0000 		call BlockLoad
 1252 04bc 00C0      		rjmp .L86
 1253               	.L54:
 316:xboot.c       ****                 else if (val == 'g')
 1255               	.LM104:
 1256 04be 8736      		cpi r24,lo8(103)
 1257 04c0 01F4      		brne .L55
 319:xboot.c       ****                         i = (get_char() << 8) | get_char();
 1259               	.LM105:
 1260 04c2 0E94 0000 		call get_char
 1261 04c6 182F      		mov r17,r24
 1262 04c8 0E94 0000 		call get_char
 1263 04cc 512E      		mov r5,r17
 1264 04ce 4424      		clr r4
 1265 04d0 882E      		mov r8,r24
 1266 04d2 9924      		clr r9
 1267 04d4 8428      		or r8,r4
 1268 04d6 9528      		or r9,r5
 321:xboot.c       ****                         val = get_char();
 1270               	.LM106:
 1271 04d8 0E94 0000 		call get_char
 1272 04dc 682F      		mov r22,r24
 1273 04de 8983      		std Y+1,r24
 323:xboot.c       ****                         BlockRead(i, val, &address);
 1275               	.LM107:
 1276 04e0 C401      		movw r24,r8
 1277 04e2 AE01      		movw r20,r28
 1278 04e4 4E5F      		subi r20,lo8(-(2))
 1279 04e6 5F4F      		sbci r21,hi8(-(2))
 1280 04e8 0E94 0000 		call BlockRead
 1281 04ec 00C0      		rjmp .L84
 1282               	.L55:
 328:xboot.c       ****                 else if (val == 'R')
 1284               	.LM108:
 1285 04ee 8235      		cpi r24,lo8(82)
 1286 04f0 01F4      		brne .L56
 330:xboot.c       ****                         SP_WaitForSPM();
 1288               	.LM109:
 1289 04f2 0E94 0000 		call SP_WaitForSPM
 331:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+1));
 1291               	.LM110:
 1292 04f6 6A81      		ldd r22,Y+2
 1293 04f8 7B81      		ldd r23,Y+3
 1294 04fa 8C81      		ldd r24,Y+4
 1295 04fc 9D81      		ldd r25,Y+5
 1296 04fe 660F      		lsl r22
 1297 0500 771F      		rol r23
 1298 0502 881F      		rol r24
 1299 0504 991F      		rol r25
 1300 0506 6F5F      		subi r22,lo8(-(1))
 1301 0508 7F4F      		sbci r23,hi8(-(1))
 1302 050a 8F4F      		sbci r24,hlo8(-(1))
 1303 050c 9F4F      		sbci r25,hhi8(-(1))
 1304 050e 0E94 0000 		call SP_ReadByte
 1305 0512 0E94 0000 		call send_char
 332:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+0));
 1307               	.LM111:
 1308 0516 6A81      		ldd r22,Y+2
 1309 0518 7B81      		ldd r23,Y+3
 1310 051a 8C81      		ldd r24,Y+4
 1311 051c 9D81      		ldd r25,Y+5
 1312 051e 660F      		lsl r22
 1313 0520 771F      		rol r23
 1314 0522 881F      		rol r24
 1315 0524 991F      		rol r25
 1316 0526 0E94 0000 		call SP_ReadByte
 1317 052a 00C0      		rjmp .L88
 1318               	.L56:
 337:xboot.c       ****                 else if (val == 'c')
 1320               	.LM112:
 1321 052c 8336      		cpi r24,lo8(99)
 1322 052e 01F4      		brne .L57
 340:xboot.c       ****                         i = get_char();
 1324               	.LM113:
 1325 0530 0E94 0000 		call get_char
 1326 0534 882E      		mov r8,r24
 1327 0536 9924      		clr r9
 1328 0538 00C0      		rjmp .L89
 1329               	.L57:
 344:xboot.c       ****                 else if (val == 'C')
 1331               	.LM114:
 1332 053a 8334      		cpi r24,lo8(67)
 1333 053c 01F4      		brne .L58
 347:xboot.c       ****                         i |= (get_char() << 8);
 1335               	.LM115:
 1336 053e 0E94 0000 		call get_char
 1337 0542 382E      		mov r3,r24
 1338 0544 2224      		clr r2
 1339 0546 8228      		or r8,r2
 1340 0548 9328      		or r9,r3
 348:xboot.c       ****                         SP_WaitForSPM();
 1342               	.LM116:
 1343 054a 0E94 0000 		call SP_WaitForSPM
 349:xboot.c       ****                         SP_LoadFlashWord((address << 1), i);
 1345               	.LM117:
 1346 054e 8A81      		ldd r24,Y+2
 1347 0550 9B81      		ldd r25,Y+3
 1348 0552 880F      		lsl r24
 1349 0554 991F      		rol r25
 1350 0556 B401      		movw r22,r8
 1351 0558 0E94 0000 		call SP_LoadFlashWord
 350:xboot.c       ****                         address++;
 1353               	.LM118:
 1354 055c 8A81      		ldd r24,Y+2
 1355 055e 9B81      		ldd r25,Y+3
 1356 0560 AC81      		ldd r26,Y+4
 1357 0562 BD81      		ldd r27,Y+5
 1358 0564 0196      		adiw r24,1
 1359 0566 A11D      		adc r26,__zero_reg__
 1360 0568 B11D      		adc r27,__zero_reg__
 1361 056a 8A83      		std Y+2,r24
 1362 056c 9B83      		std Y+3,r25
 1363 056e AC83      		std Y+4,r26
 1364 0570 BD83      		std Y+5,r27
 1365 0572 00C0      		rjmp .L89
 1366               	.L58:
 354:xboot.c       ****                 else if (val == 'm')
 1368               	.LM119:
 1369 0574 8D36      		cpi r24,lo8(109)
 1370 0576 01F4      		brne .L59
 356:xboot.c       ****                         if (address >= (APP_SECTION_SIZE>>1))
 1372               	.LM120:
 1373 0578 8A81      		ldd r24,Y+2
 1374 057a 9B81      		ldd r25,Y+3
 1375 057c AC81      		ldd r26,Y+4
 1376 057e BD81      		ldd r27,Y+5
 1377 0580 8050      		subi r24,lo8(65536)
 1378 0582 9040      		sbci r25,hi8(65536)
 1379 0584 A140      		sbci r26,hlo8(65536)
 1380 0586 B040      		sbci r27,hhi8(65536)
 1381 0588 00F0      		brlo .+2
 1382 058a 00C0      		rjmp .L92
 1383               	.L60:
 363:xboot.c       ****                                 SP_WaitForSPM();
 1385               	.LM121:
 1386 058c 0E94 0000 		call SP_WaitForSPM
 364:xboot.c       ****                                 SP_WriteApplicationPage( address << 1);
 1388               	.LM122:
 1389 0590 6A81      		ldd r22,Y+2
 1390 0592 7B81      		ldd r23,Y+3
 1391 0594 8C81      		ldd r24,Y+4
 1392 0596 9D81      		ldd r25,Y+5
 1393 0598 660F      		lsl r22
 1394 059a 771F      		rol r23
 1395 059c 881F      		rol r24
 1396 059e 991F      		rol r25
 1397 05a0 0E94 0000 		call SP_WriteApplicationPage
 1398 05a4 00C0      		rjmp .L89
 1399               	.L59:
 371:xboot.c       ****                 else if (val == 'D')
 1401               	.LM123:
 1402 05a6 8434      		cpi r24,lo8(68)
 1403 05a8 01F4      		brne .L61
 373:xboot.c       ****                         EEPROM_WriteByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (unsigned ch
 1405               	.LM124:
 1406 05aa EA80      		ldd r14,Y+2
 1407 05ac FB80      		ldd r15,Y+3
 1408 05ae 0C81      		ldd r16,Y+4
 1409 05b0 1D81      		ldd r17,Y+5
 1410 05b2 0E94 0000 		call get_char
 1411 05b6 482F      		mov r20,r24
 1412 05b8 6E2D      		mov r22,r14
 1413 05ba 6F71      		andi r22,lo8(31)
 1414 05bc F5E0      		ldi r31,5
 1415 05be 1695      	1:	lsr r17
 1416 05c0 0795      		ror r16
 1417 05c2 F794      		ror r15
 1418 05c4 E794      		ror r14
 1419 05c6 FA95      		dec r31
 1420 05c8 01F4      		brne 1b
 1421 05ca 8E2D      		mov r24,r14
 1422 05cc 0E94 0000 		call EEPROM_WriteByte
 1423 05d0 00C0      		rjmp .L87
 1424               	.L61:
 377:xboot.c       ****                 else if (val == 'd')
 1426               	.LM125:
 1427 05d2 8436      		cpi r24,lo8(100)
 1428 05d4 01F4      		brne .L62
 379:xboot.c       ****                         send_char( EEPROM_ReadByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (u
 1430               	.LM126:
 1431 05d6 8A81      		ldd r24,Y+2
 1432 05d8 9B81      		ldd r25,Y+3
 1433 05da AC81      		ldd r26,Y+4
 1434 05dc BD81      		ldd r27,Y+5
 1435 05de 682F      		mov r22,r24
 1436 05e0 6F71      		andi r22,lo8(31)
 1437 05e2 E5E0      		ldi r30,5
 1438 05e4 B695      	1:	lsr r27
 1439 05e6 A795      		ror r26
 1440 05e8 9795      		ror r25
 1441 05ea 8795      		ror r24
 1442 05ec EA95      		dec r30
 1443 05ee 01F4      		brne 1b
 1444 05f0 0E94 0000 		call EEPROM_ReadByte
 1445               	.L88:
 1446 05f4 0E94 0000 		call send_char
 1447               	.L87:
 380:xboot.c       ****                         address++;
 1449               	.LM127:
 1450 05f8 8A81      		ldd r24,Y+2
 1451 05fa 9B81      		ldd r25,Y+3
 1452 05fc AC81      		ldd r26,Y+4
 1453 05fe BD81      		ldd r27,Y+5
 1454 0600 0196      		adiw r24,1
 1455 0602 A11D      		adc r26,__zero_reg__
 1456 0604 B11D      		adc r27,__zero_reg__
 1457 0606 8A83      		std Y+2,r24
 1458 0608 9B83      		std Y+3,r25
 1459 060a AC83      		std Y+4,r26
 1460 060c BD83      		std Y+5,r27
 1461 060e 00C0      		rjmp .L84
 1462               	.L62:
 385:xboot.c       ****                 else if (val == 'l')
 1464               	.LM128:
 1465 0610 8C36      		cpi r24,lo8(108)
 1466 0612 01F4      		brne .L63
 387:xboot.c       ****                         SP_WaitForSPM();
 1468               	.LM129:
 1469 0614 0E94 0000 		call SP_WaitForSPM
 388:xboot.c       ****                         SP_WriteLockBits( get_char() );
 1471               	.LM130:
 1472 0618 0E94 0000 		call get_char
 1473 061c 0E94 0000 		call SP_WriteLockBits
 1474 0620 00C0      		rjmp .L89
 1475               	.L63:
 392:xboot.c       ****                 else if (val == 'r')
 1477               	.LM131:
 1478 0622 8237      		cpi r24,lo8(114)
 1479 0624 01F4      		brne .L64
 394:xboot.c       ****                         SP_WaitForSPM();
 1481               	.LM132:
 1482 0626 0E94 0000 		call SP_WaitForSPM
 395:xboot.c       ****                         send_char(SP_ReadLockBits());
 1484               	.LM133:
 1485 062a 0E94 0000 		call SP_ReadLockBits
 1486 062e 00C0      		rjmp .L86
 1487               	.L64:
 400:xboot.c       ****                 else if (val == 'F')
 1489               	.LM134:
 1490 0630 8634      		cpi r24,lo8(70)
 1491 0632 01F4      		brne .L65
 402:xboot.c       ****                         SP_WaitForSPM();
 1493               	.LM135:
 1494 0634 0E94 0000 		call SP_WaitForSPM
 403:xboot.c       ****                         send_char(SP_ReadFuseByte(0));
 1496               	.LM136:
 1497 0638 80E0      		ldi r24,lo8(0)
 1498 063a 00C0      		rjmp .L91
 1499               	.L65:
 406:xboot.c       ****                 else if (val == 'N')
 1501               	.LM137:
 1502 063c 8E34      		cpi r24,lo8(78)
 1503 063e 01F4      		brne .L66
 408:xboot.c       ****                         SP_WaitForSPM();
 1505               	.LM138:
 1506 0640 0E94 0000 		call SP_WaitForSPM
 409:xboot.c       ****                         send_char(SP_ReadFuseByte(1));
 1508               	.LM139:
 1509 0644 81E0      		ldi r24,lo8(1)
 1510 0646 00C0      		rjmp .L91
 1511               	.L66:
 412:xboot.c       ****                 else if (val == 'Q')
 1513               	.LM140:
 1514 0648 8135      		cpi r24,lo8(81)
 1515 064a 01F4      		brne .L67
 414:xboot.c       ****                         SP_WaitForSPM();
 1517               	.LM141:
 1518 064c 0E94 0000 		call SP_WaitForSPM
 415:xboot.c       ****                         send_char(SP_ReadFuseByte(2));
 1520               	.LM142:
 1521 0650 82E0      		ldi r24,lo8(2)
 1522               	.L91:
 1523 0652 0E94 0000 		call SP_ReadFuseByte
 1524 0656 00C0      		rjmp .L86
 1525               	.L67:
 419:xboot.c       ****                 else if ((val == 'P') || (val == 'L'))
 1527               	.LM143:
 1528 0658 8035      		cpi r24,lo8(80)
 1529 065a 01F0      		breq .L89
 1530 065c 8C34      		cpi r24,lo8(76)
 1531 065e 01F0      		breq .L89
 1532               	.L69:
 425:xboot.c       ****                 else if (val == 'E')
 1534               	.LM144:
 1535 0660 8534      		cpi r24,lo8(69)
 1536 0662 01F4      		brne .L70
 428:xboot.c       ****                         send_char('\r');
 1538               	.LM145:
 1539 0664 8DE0      		ldi r24,lo8(13)
 1540 0666 0E94 0000 		call send_char
 1541 066a 00C0      		rjmp .L85
 1542               	.L70:
 431:xboot.c       ****                 else if (val == 'p')
 1544               	.LM146:
 1545 066c 8037      		cpi r24,lo8(112)
 1546 066e 01F4      		brne .L71
 434:xboot.c       ****                         send_char('S');
 1548               	.LM147:
 1549 0670 83E5      		ldi r24,lo8(83)
 1550 0672 00C0      		rjmp .L86
 1551               	.L71:
 437:xboot.c       ****                 else if (val == 't')
 1553               	.LM148:
 1554 0674 8437      		cpi r24,lo8(116)
 1555 0676 01F4      		brne .L72
 440:xboot.c       ****                         send_char(123); // TODO
 1557               	.LM149:
 1558 0678 8BE7      		ldi r24,lo8(123)
 1559               	.L90:
 1560 067a 0E94 0000 		call send_char
 442:xboot.c       ****                         send_char(0);
 1562               	.LM150:
 1563 067e 80E0      		ldi r24,lo8(0)
 1564 0680 00C0      		rjmp .L86
 1565               	.L72:
 445:xboot.c       ****                 else if ((val == 'x') || (val == 'y') || (val == 'T'))
 1567               	.LM151:
 1568 0682 8857      		subi r24,lo8(-(-120))
 1569 0684 8230      		cpi r24,lo8(2)
 1570 0686 00F0      		brlo .L73
 1571 0688 9435      		cpi r25,lo8(84)
 1572 068a 01F4      		brne .L74
 1573               	.L73:
 448:xboot.c       ****                         get_char();
 1575               	.LM152:
 1576 068c 0E94 0000 		call get_char
 1577               	.L89:
 449:xboot.c       ****                         send_char('\r');
 1579               	.LM153:
 1580 0690 8DE0      		ldi r24,lo8(13)
 1581 0692 00C0      		rjmp .L86
 1582               	.L74:
 452:xboot.c       ****                 else if (val == 'S')
 1584               	.LM154:
 1585 0694 9335      		cpi r25,lo8(83)
 1586 0696 01F4      		brne .L75
 454:xboot.c       ****                         send_char('X');
 1588               	.LM155:
 1589 0698 88E5      		ldi r24,lo8(88)
 1590 069a 0E94 0000 		call send_char
 455:xboot.c       ****                         send_char('B');
 1592               	.LM156:
 1593 069e 82E4      		ldi r24,lo8(66)
 1594 06a0 0E94 0000 		call send_char
 456:xboot.c       ****                         send_char('o');
 1596               	.LM157:
 1597 06a4 8FE6      		ldi r24,lo8(111)
 1598 06a6 0E94 0000 		call send_char
 457:xboot.c       ****                         send_char('o');
 1600               	.LM158:
 1601 06aa 8FE6      		ldi r24,lo8(111)
 1602 06ac 0E94 0000 		call send_char
 458:xboot.c       ****                         send_char('t');
 1604               	.LM159:
 1605 06b0 84E7      		ldi r24,lo8(116)
 1606 06b2 0E94 0000 		call send_char
 459:xboot.c       ****                         send_char('+');
 1608               	.LM160:
 1609 06b6 8BE2      		ldi r24,lo8(43)
 1610 06b8 0E94 0000 		call send_char
 460:xboot.c       ****                         send_char('+');
 1612               	.LM161:
 1613 06bc 8BE2      		ldi r24,lo8(43)
 1614 06be 00C0      		rjmp .L86
 1615               	.L75:
 463:xboot.c       ****                 else if (val == 'V')
 1617               	.LM162:
 1618 06c0 9635      		cpi r25,lo8(86)
 1619 06c2 01F4      		brne .L76
 465:xboot.c       ****                         send_char('1');
 1621               	.LM163:
 1622 06c4 81E3      		ldi r24,lo8(49)
 1623 06c6 0E94 0000 		call send_char
 466:xboot.c       ****                         send_char('6');
 1625               	.LM164:
 1626 06ca 86E3      		ldi r24,lo8(54)
 1627 06cc 00C0      		rjmp .L86
 1628               	.L76:
 469:xboot.c       ****                 else if (val == 's')
 1630               	.LM165:
 1631 06ce 9337      		cpi r25,lo8(115)
 1632 06d0 01F4      		brne .L77
 471:xboot.c       ****                         send_char(SIGNATURE_2);
 1634               	.LM166:
 1635 06d2 82E4      		ldi r24,lo8(66)
 1636 06d4 0E94 0000 		call send_char
 472:xboot.c       ****                         send_char(SIGNATURE_1);
 1638               	.LM167:
 1639 06d8 87E9      		ldi r24,lo8(-105)
 1640 06da 0E94 0000 		call send_char
 473:xboot.c       ****                         send_char(SIGNATURE_0);
 1642               	.LM168:
 1643 06de 8EE1      		ldi r24,lo8(30)
 1644 06e0 00C0      		rjmp .L86
 1645               	.L77:
 613:xboot.c       ****                 else if (val != 0x1b)
 1647               	.LM169:
 1648 06e2 9B31      		cpi r25,lo8(27)
 1649 06e4 01F4      		brne .+2
 1650 06e6 00C0      		rjmp .L84
 1651               	.L92:
 615:xboot.c       ****                         send_char('?');
 1653               	.LM170:
 1654 06e8 8FE3      		ldi r24,lo8(63)
 1655               	.L86:
 1656 06ea 0E94 0000 		call send_char
 1657 06ee 00C0      		rjmp .L84
 1658               	.L85:
 625:xboot.c       ****         SP_WaitForSPM();
 1660               	.LM171:
 1661 06f0 0E94 0000 		call SP_WaitForSPM
 639:xboot.c       ****         LED_PORT.DIRCLR = (1 << LED_PIN);
 1663               	.LM172:
 1664 06f4 80E8      		ldi r24,lo8(-128)
 1665 06f6 E0E0      		ldi r30,lo8(1536)
 1666 06f8 F6E0      		ldi r31,hi8(1536)
 1667 06fa 8283      		std Z+2,r24
 663:xboot.c       ****         EIND = 0x00;
 1669               	.LM173:
 1670 06fc 1CBE      		out 60-0,__zero_reg__
 664:xboot.c       ****         reset_vect();
 1672               	.LM174:
 1673 06fe E0E0      		ldi r30,lo8(0)
 1674 0700 F0E0      		ldi r31,hi8(0)
 1675 0702 1995      		eicall
 665:xboot.c       **** }
 1677               	.LM175:
 1678 0704 80E0      		ldi r24,lo8(0)
 1679 0706 90E0      		ldi r25,hi8(0)
 1680               	/* epilogue start */
 1681 0708 2596      		adiw r28,5
 1682 070a CDBF      		out __SP_L__,r28
 1683 070c DEBF      		out __SP_H__,r29
 1684 070e CF91      		pop r28
 1685 0710 DF91      		pop r29
 1686 0712 1F91      		pop r17
 1687 0714 0F91      		pop r16
 1688 0716 FF90      		pop r15
 1689 0718 EF90      		pop r14
 1690 071a DF90      		pop r13
 1691 071c CF90      		pop r12
 1692 071e BF90      		pop r11
 1693 0720 AF90      		pop r10
 1694 0722 9F90      		pop r9
 1695 0724 8F90      		pop r8
 1696 0726 7F90      		pop r7
 1697 0728 6F90      		pop r6
 1698 072a 5F90      		pop r5
 1699 072c 4F90      		pop r4
 1700 072e 3F90      		pop r3
 1701 0730 2F90      		pop r2
 1702 0732 0895      		ret
 1711               	.Lscope5:
 1712               		.comm comm_mode,1,1
 1715               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 xboot.c
     /tmp/ccv7VvnU.s:2      *ABS*:0000003f __SREG__
     /tmp/ccv7VvnU.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccv7VvnU.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccv7VvnU.s:5      *ABS*:00000034 __CCP__
     /tmp/ccv7VvnU.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccv7VvnU.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccv7VvnU.s:399    .text:00000000 get_char
                            *COM*:00000001 comm_mode
     /tmp/ccv7VvnU.s:436    .text:0000001e send_char
     /tmp/ccv7VvnU.s:470    .text:00000042 BlockRead
     /tmp/ccv7VvnU.s:686    .text:00000178 BlockLoad
     /tmp/ccv7VvnU.s:956    .text:00000302 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
EEPROM_FlushBuffer
EEPROM_ReadByte
SP_ReadByte
SP_ReadUserSignatureByte
SP_ReadCalibrationByte
SP_WaitForSPM
EEPROM_WriteByte
SP_LoadFlashWord
SP_WriteApplicationPage
SP_EraseUserSignatureRow
SP_WriteUserSignatureRow
uart_init
SP_EraseApplicationPage
EEPROM_LoadPage
EEPROM_EraseAll
SP_WriteLockBits
SP_ReadLockBits
SP_ReadFuseByte
