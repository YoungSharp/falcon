   1               		.file	"eeprom_driver.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 402               	.global	EEPROM_WriteByte
 404               	EEPROM_WriteByte:
   0:eeprom_driver.c **** /* This file has been prepared for Doxygen automatic documentation generation.*/
   1:eeprom_driver.c **** /*! \file *********************************************************************
   2:eeprom_driver.c ****  *
   3:eeprom_driver.c ****  * \brief  XMEGA EEPROM driver source file.
   4:eeprom_driver.c ****  *
   5:eeprom_driver.c ****  *      This file contains the function implementations for the XMEGA EEPROM driver.
   6:eeprom_driver.c ****  *
   7:eeprom_driver.c ****  *      The driver is not intended for size and/or speed critical code, since
   8:eeprom_driver.c ****  *      most functions are just a few lines of code, and the function call
   9:eeprom_driver.c ****  *      overhead would decrease code performance. The driver is intended for
  10:eeprom_driver.c ****  *      rapid prototyping and documentation purposes for getting started with
  11:eeprom_driver.c ****  *      the XMEGA EEPROM module.
  12:eeprom_driver.c ****  *
  13:eeprom_driver.c ****  *      For size and/or speed critical code, it is recommended to copy the
  14:eeprom_driver.c ****  *      function contents directly into your application instead of making
  15:eeprom_driver.c ****  *      a function call.
  16:eeprom_driver.c ****  *
  17:eeprom_driver.c ****  * \par Application note:
  18:eeprom_driver.c ****  *      AVR1315: Accessing the XMEGA EEPROM
  19:eeprom_driver.c ****  *
  20:eeprom_driver.c ****  * \par Documentation
  21:eeprom_driver.c ****  *      For comprehensive code documentation, supported compilers, compiler
  22:eeprom_driver.c ****  *      settings and supported devices see readme.html
  23:eeprom_driver.c ****  *
  24:eeprom_driver.c ****  * \author
  25:eeprom_driver.c ****  *      Atmel Corporation: http://www.atmel.com \n
  26:eeprom_driver.c ****  *      Support email: avr@atmel.com
  27:eeprom_driver.c ****  *
  28:eeprom_driver.c ****  * $Revision: 1 $
  29:eeprom_driver.c ****  * $Date: 2009-04-22 13:03:43 +0200 (ti, 22 apr 2009) $  \n
  30:eeprom_driver.c ****  *
  31:eeprom_driver.c ****  * Copyright (c) 2009, Atmel Corporation All rights reserved.
  32:eeprom_driver.c ****  *
  33:eeprom_driver.c ****  * Redistribution and use in source and binary forms, with or without
  34:eeprom_driver.c ****  * modification, are permitted provided that the following conditions are met:
  35:eeprom_driver.c ****  *
  36:eeprom_driver.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  37:eeprom_driver.c ****  * this list of conditions and the following disclaimer.
  38:eeprom_driver.c ****  *
  39:eeprom_driver.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  40:eeprom_driver.c ****  * this list of conditions and the following disclaimer in the documentation
  41:eeprom_driver.c ****  * and/or other materials provided with the distribution.
  42:eeprom_driver.c ****  *
  43:eeprom_driver.c ****  * 3. The name of ATMEL may not be used to endorse or promote products derived
  44:eeprom_driver.c ****  * from this software without specific prior written permission.
  45:eeprom_driver.c ****  *
  46:eeprom_driver.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  47:eeprom_driver.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  48:eeprom_driver.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
  49:eeprom_driver.c ****  * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
  50:eeprom_driver.c ****  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  51:eeprom_driver.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  52:eeprom_driver.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  53:eeprom_driver.c ****  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  54:eeprom_driver.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  55:eeprom_driver.c ****  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  56:eeprom_driver.c ****  *****************************************************************************/
  57:eeprom_driver.c **** 
  58:eeprom_driver.c **** #include "eeprom_driver.h"
  59:eeprom_driver.c **** 
  60:eeprom_driver.c **** static inline void NVM_EXEC(void)
  61:eeprom_driver.c **** {
  62:eeprom_driver.c ****         void *z = (void *)&NVM_CTRLA;
  63:eeprom_driver.c ****         
  64:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
  65:eeprom_driver.c ****         "st z, %[cmdex]"
  66:eeprom_driver.c ****         :
  67:eeprom_driver.c ****         : [ccp] "I" (_SFR_IO_ADDR(CCP)),
  68:eeprom_driver.c ****         [ioreg] "d" (CCP_IOREG_gc),
  69:eeprom_driver.c ****                      [cmdex] "r" (NVM_CMDEX_bm),
  70:eeprom_driver.c ****                      [z] "z" (z)
  71:eeprom_driver.c ****                      );
  72:eeprom_driver.c **** }
  73:eeprom_driver.c **** 
  74:eeprom_driver.c **** #ifdef USE_AVR1008_EEPROM
  75:eeprom_driver.c **** 
  76:eeprom_driver.c **** // Interrupt handler for the EEPROM write "done" interrupt
  77:eeprom_driver.c **** ISR(NVM_EE_vect)
  78:eeprom_driver.c **** {
  79:eeprom_driver.c ****         // Disable the EEPROM interrupt
  80:eeprom_driver.c ****         NVM.INTCTRL = (NVM.INTCTRL & ~NVM_EELVL_gm);
  81:eeprom_driver.c **** }
  82:eeprom_driver.c **** 
  83:eeprom_driver.c **** // AVR1008 fix
  84:eeprom_driver.c **** static inline void NVM_EXEC_WRAPPER(void)
  85:eeprom_driver.c **** {
  86:eeprom_driver.c ****         // Save the Sleep register
  87:eeprom_driver.c ****         uint8_t sleepCtr = SLEEP.CTRL;
  88:eeprom_driver.c ****         // Set sleep mode to IDLE
  89:eeprom_driver.c ****         SLEEP.CTRL = (SLEEP.CTRL & ~SLEEP.CTRL) | SLEEP_SMODE_IDLE_gc;
  90:eeprom_driver.c ****         // Save the PMIC Status and control registers
  91:eeprom_driver.c ****         uint8_t statusStore = PMIC.STATUS;
  92:eeprom_driver.c ****         uint8_t pmicStore = PMIC.CTRL;
  93:eeprom_driver.c ****         
  94:eeprom_driver.c ****         // Enable only the highest level of interrupts
  95:eeprom_driver.c ****         PMIC.CTRL = (PMIC.CTRL & ~(PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm)) | PMIC_HILVLEN_bm;
  96:eeprom_driver.c ****         // Save SREG for later use
  97:eeprom_driver.c ****         uint8_t globalInt = SREG;
  98:eeprom_driver.c ****         // Enable global interrupts
  99:eeprom_driver.c ****         sei();
 100:eeprom_driver.c ****         // Set sleep enabled
 101:eeprom_driver.c ****         SLEEP.CTRL |= SLEEP_SEN_bm;
 102:eeprom_driver.c ****         // Save eeprom interrupt settings for later
 103:eeprom_driver.c ****         uint8_t eepromintStore = NVM.INTCTRL;
 104:eeprom_driver.c ****         NVM_EXEC();
 105:eeprom_driver.c ****         // Enable EEPROM interrupt
 106:eeprom_driver.c ****         NVM.INTCTRL =  NVM_EELVL0_bm | NVM_EELVL1_bm;
 107:eeprom_driver.c ****         // Sleep before 2.5uS has passed
 108:eeprom_driver.c ****         sleep_cpu();
 109:eeprom_driver.c ****         // Restore sleep settings
 110:eeprom_driver.c ****         SLEEP.CTRL = sleepCtr;
 111:eeprom_driver.c ****         // Restore PMIC status and control registers
 112:eeprom_driver.c ****         PMIC.STATUS = statusStore;
 113:eeprom_driver.c ****         PMIC.CTRL = pmicStore;
 114:eeprom_driver.c ****         // Restore EEPROM interruptsettings
 115:eeprom_driver.c ****         NVM.INTCTRL = eepromintStore;
 116:eeprom_driver.c ****         // Restore global interrupt settings
 117:eeprom_driver.c ****         SREG = globalInt;
 118:eeprom_driver.c **** }
 119:eeprom_driver.c **** 
 120:eeprom_driver.c **** #else
 121:eeprom_driver.c **** 
 122:eeprom_driver.c **** #define NVM_EXEC_WRAPPER NVM_EXEC
 123:eeprom_driver.c **** 
 124:eeprom_driver.c **** #endif // USE_AVR1008_EEPROM
 125:eeprom_driver.c **** 
 126:eeprom_driver.c **** /*! \brief Write one byte to EEPROM using IO mapping.
 127:eeprom_driver.c ****  *
 128:eeprom_driver.c ****  *  This function writes one byte to EEPROM using IO-mapped access.
 129:eeprom_driver.c ****  *  Please note that the memory mapped EERPROM can not be used when using this function.
 130:eeprom_driver.c ****  *  This functiom will cancel all ongoing EEPROM page buffer loading
 131:eeprom_driver.c ****  *  operations, if any.
 132:eeprom_driver.c ****  *
 133:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 134:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 135:eeprom_driver.c ****  *  \param  value     Byte value to write to EEPROM.
 136:eeprom_driver.c ****  */
 137:eeprom_driver.c **** void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value )
 138:eeprom_driver.c **** {
 406               	.LM0:
 407               	.LFBB1:
 408               	/* prologue: function */
 409               	/* frame size = 0 */
 410 0000 582F      		mov r21,r24
 411               	.L2:
 412               	.LBB39:
 413               	.LBB40:
 414               	.LBB41:
 415               	.LBB42:
 139:eeprom_driver.c **** 	/*  Flush buffer to make sure no unintetional data is written and load
 140:eeprom_driver.c **** 	 *  the "Page Load" command into the command register.
 141:eeprom_driver.c **** 	 */
 142:eeprom_driver.c **** 	EEPROM_FlushBuffer();
 143:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 144:eeprom_driver.c **** 
 145:eeprom_driver.c **** 	/* Calculate address */
 146:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE)
 147:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 148:eeprom_driver.c **** 
 149:eeprom_driver.c **** 	/* Set address to write to. */
 150:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 151:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 152:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 153:eeprom_driver.c **** 
 154:eeprom_driver.c **** 	/* Load data to write, which triggers the loading of EEPROM page buffer. */
 155:eeprom_driver.c **** 	NVM.DATA0 = value;
 156:eeprom_driver.c **** 
 157:eeprom_driver.c **** 	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
 158:eeprom_driver.c **** 	 *  the protection signature and execute command.
 159:eeprom_driver.c **** 	 */
 160:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
 161:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 162:eeprom_driver.c **** }
 163:eeprom_driver.c **** 
 164:eeprom_driver.c **** 
 165:eeprom_driver.c **** /*! \brief Read one byte from EEPROM using IO mapping.
 166:eeprom_driver.c ****  *
 167:eeprom_driver.c ****  *  This function reads one byte from EEPROM using IO-mapped access.
 168:eeprom_driver.c ****  *  Please note that the memory mapped EERPROM can not be used when using this function.
 169:eeprom_driver.c ****  *
 170:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 171:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 172:eeprom_driver.c ****  *
 173:eeprom_driver.c ****  *  \return  Byte value read from EEPROM.
 174:eeprom_driver.c ****  */
 175:eeprom_driver.c **** uint8_t EEPROM_ReadByte( uint8_t pageAddr, uint8_t byteAddr )
 176:eeprom_driver.c **** {
 177:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 178:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 179:eeprom_driver.c **** 
 180:eeprom_driver.c **** 	/* Calculate address */
 181:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE)
 182:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 183:eeprom_driver.c **** 
 184:eeprom_driver.c **** 	/* Set address to read from. */
 185:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 186:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 187:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 188:eeprom_driver.c **** 
 189:eeprom_driver.c **** 	/* Issue EEPROM Read command. */
 190:eeprom_driver.c ****         NVM.CMD = NVM_CMD_READ_EEPROM_gc;
 191:eeprom_driver.c ****         NVM_EXEC();
 192:eeprom_driver.c **** 
 193:eeprom_driver.c **** 	return NVM.DATA0;
 194:eeprom_driver.c **** }
 195:eeprom_driver.c **** 
 196:eeprom_driver.c **** 
 197:eeprom_driver.c **** /*! \brief Wait for any NVM access to finish, including EEPROM.
 198:eeprom_driver.c ****  *
 199:eeprom_driver.c ****  *  This function is blcoking and waits for any NVM access to finish,
 200:eeprom_driver.c ****  *  including EEPROM. Use this function before any EEPROM accesses,
 201:eeprom_driver.c ****  *  if you are not certain that any previous operations are finished yet,
 202:eeprom_driver.c ****  *  like an EEPROM write.
 203:eeprom_driver.c ****  */
 204:eeprom_driver.c **** void EEPROM_WaitForNVM( void )
 205:eeprom_driver.c **** {
 206:eeprom_driver.c **** 	do {
 207:eeprom_driver.c **** 		/* Block execution while waiting for the NVM to be ready. */
 208:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 417               	.LM1:
 418 0002 8091 CF01 		lds r24,463
 419 0006 87FD      		sbrc r24,7
 420 0008 00C0      		rjmp .L2
 421               	.LBE42:
 422               	.LBE41:
 209:eeprom_driver.c **** }
 210:eeprom_driver.c **** 
 211:eeprom_driver.c **** 
 212:eeprom_driver.c **** /*! \brief Flush temporary EEPROM page buffer.
 213:eeprom_driver.c ****  *
 214:eeprom_driver.c ****  *  This function flushes the EEPROM page buffers. This function will cancel
 215:eeprom_driver.c ****  *  any ongoing EEPROM page buffer loading operations, if any.
 216:eeprom_driver.c ****  *  This function also works for memory mapped EEPROM access.
 217:eeprom_driver.c ****  *
 218:eeprom_driver.c ****  *  \note The EEPROM write operations will automatically flush the buffer for you.
 219:eeprom_driver.c ****  */
 220:eeprom_driver.c **** void EEPROM_FlushBuffer( void )
 221:eeprom_driver.c **** {
 222:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 223:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 224:eeprom_driver.c **** 
 225:eeprom_driver.c **** 	/* Flush EEPROM page buffer if necessary. */
 226:eeprom_driver.c **** 	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
 424               	.LM2:
 425 000a 8091 CF01 		lds r24,463
 426 000e 81FF      		sbrs r24,1
 427 0010 00C0      		rjmp .L3
 227:eeprom_driver.c ****                 NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
 429               	.LM3:
 430 0012 86E3      		ldi r24,lo8(54)
 431 0014 E0EC      		ldi r30,lo8(448)
 432 0016 F1E0      		ldi r31,hi8(448)
 433 0018 8287      		std Z+10,r24
 434               	.LBB43:
 435               	.LBB44:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 437               	.LM4:
 438 001a EBEC      		ldi r30,lo8(459)
 439 001c F1E0      		ldi r31,hi8(459)
 440 001e 21E0      		ldi r18,lo8(1)
 441 0020 30E0      		ldi r19,hi8(1)
 442 0022 88ED      		ldi r24,lo8(216)
 443 0024 90E0      		ldi r25,hi8(216)
 444               	/* #APP */
 445               	 ;  65 "eeprom_driver.c" 1
 446 0026 84BF      		out 52, r24
 447 0028 2083      		st z, r18
 448               	 ;  0 "" 2
 449               	/* #NOAPP */
 450               	.L3:
 451               	.LBE44:
 452               	.LBE43:
 453               	.LBE40:
 454               	.LBE39:
 144:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 456               	.LM5:
 457 002a E0EC      		ldi r30,lo8(448)
 458 002c F1E0      		ldi r31,hi8(448)
 459 002e 83E3      		ldi r24,lo8(51)
 460 0030 8287      		std Z+10,r24
 148:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 462               	.LM6:
 463 0032 262F      		mov r18,r22
 464 0034 30E0      		ldi r19,lo8(0)
 465 0036 2F71      		andi r18,lo8(31)
 466 0038 3070      		andi r19,hi8(31)
 467 003a 852F      		mov r24,r21
 468 003c 90E0      		ldi r25,lo8(0)
 469 003e 55E0      		ldi r21,5
 470 0040 880F      	1:	lsl r24
 471 0042 991F      		rol r25
 472 0044 5A95      		dec r21
 473 0046 01F4      		brne 1b
 474 0048 282B      		or r18,r24
 475 004a 392B      		or r19,r25
 151:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 477               	.LM7:
 478 004c 2093 C001 		sts 448,r18
 152:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 480               	.LM8:
 481 0050 832F      		mov r24,r19
 482 0052 8F71      		andi r24,lo8(31)
 483 0054 8183      		std Z+1,r24
 153:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 485               	.LM9:
 486 0056 1282      		std Z+2,__zero_reg__
 156:eeprom_driver.c **** 	NVM.DATA0 = value;
 488               	.LM10:
 489 0058 4483      		std Z+4,r20
 161:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
 491               	.LM11:
 492 005a 85E3      		ldi r24,lo8(53)
 493 005c 8287      		std Z+10,r24
 494               	.LBB45:
 495               	.LBB46:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 497               	.LM12:
 498 005e EBEC      		ldi r30,lo8(459)
 499 0060 F1E0      		ldi r31,hi8(459)
 500 0062 21E0      		ldi r18,lo8(1)
 501 0064 30E0      		ldi r19,hi8(1)
 502 0066 88ED      		ldi r24,lo8(216)
 503 0068 90E0      		ldi r25,hi8(216)
 504               	/* #APP */
 505               	 ;  65 "eeprom_driver.c" 1
 506 006a 84BF      		out 52, r24
 507 006c 2083      		st z, r18
 508               	 ;  0 "" 2
 509               	/* epilogue start */
 510               	/* #NOAPP */
 511               	.LBE46:
 512               	.LBE45:
 163:eeprom_driver.c **** }
 514               	.LM13:
 515 006e 0895      		ret
 520               	.Lscope1:
 524               	.global	EEPROM_ReadByte
 526               	EEPROM_ReadByte:
 177:eeprom_driver.c **** {
 528               	.LM14:
 529               	.LFBB2:
 530               	/* prologue: function */
 531               	/* frame size = 0 */
 532 0070 982F      		mov r25,r24
 533               	.L7:
 534               	.LBB47:
 535               	.LBB48:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 537               	.LM15:
 538 0072 E0EC      		ldi r30,lo8(448)
 539 0074 F1E0      		ldi r31,hi8(448)
 540 0076 8091 CF01 		lds r24,463
 541 007a 87FD      		sbrc r24,7
 542 007c 00C0      		rjmp .L7
 543               	.LBE48:
 544               	.LBE47:
 183:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 546               	.LM16:
 547 007e 262F      		mov r18,r22
 548 0080 30E0      		ldi r19,lo8(0)
 549 0082 2F71      		andi r18,lo8(31)
 550 0084 3070      		andi r19,hi8(31)
 551 0086 892F      		mov r24,r25
 552 0088 90E0      		ldi r25,lo8(0)
 553 008a 65E0      		ldi r22,5
 554 008c 880F      	1:	lsl r24
 555 008e 991F      		rol r25
 556 0090 6A95      		dec r22
 557 0092 01F4      		brne 1b
 558 0094 282B      		or r18,r24
 559 0096 392B      		or r19,r25
 186:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 561               	.LM17:
 562 0098 2093 C001 		sts 448,r18
 187:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 564               	.LM18:
 565 009c 832F      		mov r24,r19
 566 009e 8F71      		andi r24,lo8(31)
 567 00a0 8183      		std Z+1,r24
 188:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 569               	.LM19:
 570 00a2 1282      		std Z+2,__zero_reg__
 191:eeprom_driver.c ****         NVM.CMD = NVM_CMD_READ_EEPROM_gc;
 572               	.LM20:
 573 00a4 86E0      		ldi r24,lo8(6)
 574 00a6 8287      		std Z+10,r24
 575               	.LBB49:
 576               	.LBB50:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 578               	.LM21:
 579 00a8 EBEC      		ldi r30,lo8(459)
 580 00aa F1E0      		ldi r31,hi8(459)
 581 00ac 21E0      		ldi r18,lo8(1)
 582 00ae 30E0      		ldi r19,hi8(1)
 583 00b0 88ED      		ldi r24,lo8(216)
 584 00b2 90E0      		ldi r25,hi8(216)
 585               	/* #APP */
 586               	 ;  65 "eeprom_driver.c" 1
 587 00b4 84BF      		out 52, r24
 588 00b6 2083      		st z, r18
 589               	 ;  0 "" 2
 590               	/* #NOAPP */
 591               	.LBE50:
 592               	.LBE49:
 194:eeprom_driver.c **** 	return NVM.DATA0;
 594               	.LM22:
 595 00b8 8091 C401 		lds r24,452
 596               	/* epilogue start */
 195:eeprom_driver.c **** }
 598               	.LM23:
 599 00bc 0895      		ret
 604               	.Lscope2:
 606               	.global	EEPROM_WaitForNVM
 608               	EEPROM_WaitForNVM:
 206:eeprom_driver.c **** {
 610               	.LM24:
 611               	.LFBB3:
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	.L11:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 616               	.LM25:
 617 00be 8091 CF01 		lds r24,463
 618 00c2 87FD      		sbrc r24,7
 619 00c4 00C0      		rjmp .L11
 620               	/* epilogue start */
 210:eeprom_driver.c **** }
 622               	.LM26:
 623 00c6 0895      		ret
 625               	.Lscope3:
 627               	.global	EEPROM_FlushBuffer
 629               	EEPROM_FlushBuffer:
 222:eeprom_driver.c **** {
 631               	.LM27:
 632               	.LFBB4:
 633               	/* prologue: function */
 634               	/* frame size = 0 */
 635               	.L15:
 636               	.LBB51:
 637               	.LBB52:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 639               	.LM28:
 640 00c8 8091 CF01 		lds r24,463
 641 00cc 87FD      		sbrc r24,7
 642 00ce 00C0      		rjmp .L15
 643               	.LBE52:
 644               	.LBE51:
 227:eeprom_driver.c **** 	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
 646               	.LM29:
 647 00d0 8091 CF01 		lds r24,463
 648 00d4 81FF      		sbrs r24,1
 649 00d6 00C0      		rjmp .L17
 651               	.LM30:
 652 00d8 86E3      		ldi r24,lo8(54)
 653 00da E0EC      		ldi r30,lo8(448)
 654 00dc F1E0      		ldi r31,hi8(448)
 655 00de 8287      		std Z+10,r24
 656               	.LBB53:
 657               	.LBB54:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 659               	.LM31:
 660 00e0 EBEC      		ldi r30,lo8(459)
 661 00e2 F1E0      		ldi r31,hi8(459)
 662 00e4 21E0      		ldi r18,lo8(1)
 663 00e6 30E0      		ldi r19,hi8(1)
 664 00e8 88ED      		ldi r24,lo8(216)
 665 00ea 90E0      		ldi r25,hi8(216)
 666               	/* #APP */
 667               	 ;  65 "eeprom_driver.c" 1
 668 00ec 84BF      		out 52, r24
 669 00ee 2083      		st z, r18
 670               	 ;  0 "" 2
 671               	/* #NOAPP */
 672               	.L17:
 673 00f0 0895      		ret
 674               	.LBE54:
 675               	.LBE53:
 677               	.Lscope4:
 681               	.global	EEPROM_LoadByte
 683               	EEPROM_LoadByte:
 228:eeprom_driver.c ****                 NVM_EXEC();
 229:eeprom_driver.c **** 	}
 230:eeprom_driver.c **** }
 231:eeprom_driver.c **** 
 232:eeprom_driver.c **** 
 233:eeprom_driver.c **** /*! \brief Load single byte into temporary page buffer.
 234:eeprom_driver.c ****  *
 235:eeprom_driver.c ****  *  This function loads one byte into the temporary EEPROM page buffers.
 236:eeprom_driver.c ****  *  If memory mapped EEPROM is enabled, this function will not work.
 237:eeprom_driver.c ****  *  Make sure that the buffer is flushed before starting to load bytes.
 238:eeprom_driver.c ****  *  Also, if multiple bytes are loaded into the same location, they will
 239:eeprom_driver.c ****  *  be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.
 240:eeprom_driver.c ****  *
 241:eeprom_driver.c ****  *  \note Only one page buffer exist, thus only one page can be loaded with
 242:eeprom_driver.c ****  *        data and programmed into one page. If data needs to be written to
 243:eeprom_driver.c ****  *        different pages, the loading and writing needs to be repeated.
 244:eeprom_driver.c ****  *
 245:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 246:eeprom_driver.c ****  *  \param  value     Byte value to write to buffer.
 247:eeprom_driver.c ****  */
 248:eeprom_driver.c **** void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
 249:eeprom_driver.c **** {
 685               	.LM32:
 686               	.LFBB5:
 687               	/* prologue: function */
 688               	/* frame size = 0 */
 689 00f2 982F      		mov r25,r24
 690               	.L20:
 691               	.LBB55:
 692               	.LBB56:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 694               	.LM33:
 695 00f4 E0EC      		ldi r30,lo8(448)
 696 00f6 F1E0      		ldi r31,hi8(448)
 697 00f8 8091 CF01 		lds r24,463
 698 00fc 87FD      		sbrc r24,7
 699 00fe 00C0      		rjmp .L20
 700               	.LBE56:
 701               	.LBE55:
 250:eeprom_driver.c **** 	/* Wait until NVM is not busy and prepare NVM command.*/
 251:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 252:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 703               	.LM34:
 704 0100 83E3      		ldi r24,lo8(51)
 705 0102 8287      		std Z+10,r24
 253:eeprom_driver.c **** 
 254:eeprom_driver.c **** 	/* Set address. */
 255:eeprom_driver.c **** 	NVM.ADDR0 = byteAddr & 0xFF;
 707               	.LM35:
 708 0104 9093 C001 		sts 448,r25
 256:eeprom_driver.c **** 	NVM.ADDR1 = 0x00;
 710               	.LM36:
 711 0108 1182      		std Z+1,__zero_reg__
 257:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 713               	.LM37:
 714 010a 1282      		std Z+2,__zero_reg__
 258:eeprom_driver.c **** 
 259:eeprom_driver.c **** 	/* Set data, which triggers loading of EEPROM page buffer. */
 260:eeprom_driver.c **** 	NVM.DATA0 = value;
 716               	.LM38:
 717 010c 6483      		std Z+4,r22
 718               	/* epilogue start */
 261:eeprom_driver.c **** }
 720               	.LM39:
 721 010e 0895      		ret
 723               	.Lscope5:
 726               	.global	EEPROM_LoadPage
 728               	EEPROM_LoadPage:
 262:eeprom_driver.c **** 
 263:eeprom_driver.c **** 
 264:eeprom_driver.c **** /*! \brief Load entire page into temporary EEPROM page buffer.
 265:eeprom_driver.c ****  *
 266:eeprom_driver.c ****  *  This function loads an entire EEPROM page from an SRAM buffer to
 267:eeprom_driver.c ****  *  the EEPROM page buffers. Please note that the memory mapped EERPROM can not be used when using 
 268:eeprom_driver.c ****  *  Make sure that the buffer is flushed before
 269:eeprom_driver.c ****  *  starting to load bytes.
 270:eeprom_driver.c ****  *
 271:eeprom_driver.c ****  *  \note Only the lower part of the address is used to address the buffer.
 272:eeprom_driver.c ****  *        Therefore, no address parameter is needed. In the end, the data
 273:eeprom_driver.c ****  *        is written to the EEPROM page given by the address parameter to the
 274:eeprom_driver.c ****  *        EEPROM write page operation.
 275:eeprom_driver.c ****  *
 276:eeprom_driver.c ****  *  \param  values   Pointer to SRAM buffer containing an entire page.
 277:eeprom_driver.c ****  */
 278:eeprom_driver.c **** void EEPROM_LoadPage( const uint8_t * values )
 279:eeprom_driver.c **** {
 730               	.LM40:
 731               	.LFBB6:
 732               	/* prologue: function */
 733               	/* frame size = 0 */
 734 0110 DC01      		movw r26,r24
 735               	.L24:
 736               	.LBB57:
 737               	.LBB58:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 739               	.LM41:
 740 0112 E0EC      		ldi r30,lo8(448)
 741 0114 F1E0      		ldi r31,hi8(448)
 742 0116 8091 CF01 		lds r24,463
 743 011a 87FD      		sbrc r24,7
 744 011c 00C0      		rjmp .L24
 745               	.LBE58:
 746               	.LBE57:
 280:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 281:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 282:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 748               	.LM42:
 749 011e 83E3      		ldi r24,lo8(51)
 750 0120 8287      		std Z+10,r24
 283:eeprom_driver.c **** 
 284:eeprom_driver.c **** 	/*  Set address to zero, as only the lower bits matters. ADDR0 is
 285:eeprom_driver.c **** 	 *  maintained inside the loop below.
 286:eeprom_driver.c **** 	 */
 287:eeprom_driver.c **** 	NVM.ADDR1 = 0x00;
 752               	.LM43:
 753 0122 1182      		std Z+1,__zero_reg__
 288:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 755               	.LM44:
 756 0124 1282      		std Z+2,__zero_reg__
 757 0126 90E0      		ldi r25,lo8(0)
 758               	.L25:
 759               	.LBB59:
 289:eeprom_driver.c **** 
 290:eeprom_driver.c **** 	/* Load multible bytes into page buffer. */
 291:eeprom_driver.c **** 	for (uint8_t i = 0; i < EEPROM_PAGE_SIZE; ++i) {
 292:eeprom_driver.c **** 		NVM.ADDR0 = i;
 761               	.LM45:
 762 0128 9093 C001 		sts 448,r25
 293:eeprom_driver.c **** 		NVM.DATA0 = *values;
 764               	.LM46:
 765 012c 8D91      		ld r24,X+
 766 012e 8483      		std Z+4,r24
 292:eeprom_driver.c **** 	for (uint8_t i = 0; i < EEPROM_PAGE_SIZE; ++i) {
 768               	.LM47:
 769 0130 9F5F      		subi r25,lo8(-(1))
 770 0132 9032      		cpi r25,lo8(32)
 771 0134 01F4      		brne .L25
 772               	/* epilogue start */
 773               	.LBE59:
 294:eeprom_driver.c **** 		++values;
 295:eeprom_driver.c **** 	}
 296:eeprom_driver.c **** }
 775               	.LM48:
 776 0136 0895      		ret
 781               	.Lscope6:
 784               	.global	EEPROM_AtomicWritePage
 786               	EEPROM_AtomicWritePage:
 297:eeprom_driver.c **** 
 298:eeprom_driver.c **** /*! \brief Write already loaded page into EEPROM.
 299:eeprom_driver.c ****  *
 300:eeprom_driver.c ****  *  This function writes the contents of an already loaded EEPROM page
 301:eeprom_driver.c ****  *  buffer into EEPROM memory.
 302:eeprom_driver.c ****  *
 303:eeprom_driver.c ****  *  As this is an atomic write, the page in EEPROM will be erased
 304:eeprom_driver.c ****  *  automatically before writing. Note that only the page buffer locations
 305:eeprom_driver.c ****  *  that have been loaded will be used when writing to EEPROM. Page buffer
 306:eeprom_driver.c ****  *  locations that have not been loaded will be left untouched in EEPROM.
 307:eeprom_driver.c ****  *
 308:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 309:eeprom_driver.c ****  */
 310:eeprom_driver.c **** void EEPROM_AtomicWritePage( uint8_t pageAddr )
 311:eeprom_driver.c **** {
 788               	.LM49:
 789               	.LFBB7:
 790               	/* prologue: function */
 791               	/* frame size = 0 */
 792 0138 982F      		mov r25,r24
 793               	.L30:
 794               	.LBB60:
 795               	.LBB61:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 797               	.LM50:
 798 013a E0EC      		ldi r30,lo8(448)
 799 013c F1E0      		ldi r31,hi8(448)
 800 013e 8091 CF01 		lds r24,463
 801 0142 87FD      		sbrc r24,7
 802 0144 00C0      		rjmp .L30
 803               	.LBE61:
 804               	.LBE60:
 312:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 313:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 314:eeprom_driver.c **** 
 315:eeprom_driver.c **** 	/* Calculate page address */
 316:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 806               	.LM51:
 807 0146 892F      		mov r24,r25
 808 0148 90E0      		ldi r25,lo8(0)
 809 014a 75E0      		ldi r23,5
 810 014c 880F      	1:	lsl r24
 811 014e 991F      		rol r25
 812 0150 7A95      		dec r23
 813 0152 01F4      		brne 1b
 317:eeprom_driver.c **** 
 318:eeprom_driver.c **** 	/* Set address. */
 319:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 815               	.LM52:
 816 0154 8093 C001 		sts 448,r24
 320:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 818               	.LM53:
 819 0158 892F      		mov r24,r25
 820 015a 8F71      		andi r24,lo8(31)
 821 015c 8183      		std Z+1,r24
 321:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 823               	.LM54:
 824 015e 1282      		std Z+2,__zero_reg__
 322:eeprom_driver.c **** 
 323:eeprom_driver.c **** 	/* Issue EEPROM Atomic Write (Erase&Write) command. */
 324:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
 826               	.LM55:
 827 0160 85E3      		ldi r24,lo8(53)
 828 0162 8287      		std Z+10,r24
 829               	.LBB62:
 830               	.LBB63:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 832               	.LM56:
 833 0164 EBEC      		ldi r30,lo8(459)
 834 0166 F1E0      		ldi r31,hi8(459)
 835 0168 21E0      		ldi r18,lo8(1)
 836 016a 30E0      		ldi r19,hi8(1)
 837 016c 88ED      		ldi r24,lo8(216)
 838 016e 90E0      		ldi r25,hi8(216)
 839               	/* #APP */
 840               	 ;  65 "eeprom_driver.c" 1
 841 0170 84BF      		out 52, r24
 842 0172 2083      		st z, r18
 843               	 ;  0 "" 2
 844               	/* epilogue start */
 845               	/* #NOAPP */
 846               	.LBE63:
 847               	.LBE62:
 325:eeprom_driver.c ****         NVM_EXEC();
 326:eeprom_driver.c **** }
 849               	.LM57:
 850 0174 0895      		ret
 855               	.Lscope7:
 858               	.global	EEPROM_ErasePage
 860               	EEPROM_ErasePage:
 327:eeprom_driver.c **** 
 328:eeprom_driver.c **** 
 329:eeprom_driver.c **** /*! \brief Erase EEPROM page.
 330:eeprom_driver.c ****  *
 331:eeprom_driver.c ****  *  This function erases one EEPROM page, so that every location reads 0xFF.
 332:eeprom_driver.c ****  *
 333:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 334:eeprom_driver.c ****  */
 335:eeprom_driver.c **** void EEPROM_ErasePage( uint8_t pageAddr )
 336:eeprom_driver.c **** {
 862               	.LM58:
 863               	.LFBB8:
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866 0176 982F      		mov r25,r24
 867               	.L34:
 868               	.LBB64:
 869               	.LBB65:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 871               	.LM59:
 872 0178 E0EC      		ldi r30,lo8(448)
 873 017a F1E0      		ldi r31,hi8(448)
 874 017c 8091 CF01 		lds r24,463
 875 0180 87FD      		sbrc r24,7
 876 0182 00C0      		rjmp .L34
 877               	.LBE65:
 878               	.LBE64:
 337:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 338:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 339:eeprom_driver.c **** 
 340:eeprom_driver.c **** 	/* Calculate page address */
 341:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 880               	.LM60:
 881 0184 892F      		mov r24,r25
 882 0186 90E0      		ldi r25,lo8(0)
 883 0188 A5E0      		ldi r26,5
 884 018a 880F      	1:	lsl r24
 885 018c 991F      		rol r25
 886 018e AA95      		dec r26
 887 0190 01F4      		brne 1b
 342:eeprom_driver.c **** 
 343:eeprom_driver.c **** 	/* Set address. */
 344:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 889               	.LM61:
 890 0192 8093 C001 		sts 448,r24
 345:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 892               	.LM62:
 893 0196 892F      		mov r24,r25
 894 0198 8F71      		andi r24,lo8(31)
 895 019a 8183      		std Z+1,r24
 346:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 897               	.LM63:
 898 019c 1282      		std Z+2,__zero_reg__
 347:eeprom_driver.c **** 
 348:eeprom_driver.c **** 	/* Issue EEPROM Erase command. */
 349:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_EEPROM_PAGE_gc;
 900               	.LM64:
 901 019e 82E3      		ldi r24,lo8(50)
 902 01a0 8287      		std Z+10,r24
 903               	.LBB66:
 904               	.LBB67:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 906               	.LM65:
 907 01a2 EBEC      		ldi r30,lo8(459)
 908 01a4 F1E0      		ldi r31,hi8(459)
 909 01a6 21E0      		ldi r18,lo8(1)
 910 01a8 30E0      		ldi r19,hi8(1)
 911 01aa 88ED      		ldi r24,lo8(216)
 912 01ac 90E0      		ldi r25,hi8(216)
 913               	/* #APP */
 914               	 ;  65 "eeprom_driver.c" 1
 915 01ae 84BF      		out 52, r24
 916 01b0 2083      		st z, r18
 917               	 ;  0 "" 2
 918               	/* epilogue start */
 919               	/* #NOAPP */
 920               	.LBE67:
 921               	.LBE66:
 350:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 351:eeprom_driver.c **** }
 923               	.LM66:
 924 01b2 0895      		ret
 929               	.Lscope8:
 932               	.global	EEPROM_SplitWritePage
 934               	EEPROM_SplitWritePage:
 352:eeprom_driver.c **** 
 353:eeprom_driver.c **** 
 354:eeprom_driver.c **** /*! \brief Write (without erasing) EEPROM page.
 355:eeprom_driver.c ****  *
 356:eeprom_driver.c ****  *  This function writes the contents of an already loaded EEPROM page
 357:eeprom_driver.c ****  *  buffer into EEPROM memory.
 358:eeprom_driver.c ****  *
 359:eeprom_driver.c ****  *  As this is a split write, the page in EEPROM will _not_ be erased
 360:eeprom_driver.c ****  *  before writing.
 361:eeprom_driver.c ****  *
 362:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 363:eeprom_driver.c ****  */
 364:eeprom_driver.c **** void EEPROM_SplitWritePage( uint8_t pageAddr )
 365:eeprom_driver.c **** {
 936               	.LM67:
 937               	.LFBB9:
 938               	/* prologue: function */
 939               	/* frame size = 0 */
 940 01b4 982F      		mov r25,r24
 941               	.L38:
 942               	.LBB68:
 943               	.LBB69:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 945               	.LM68:
 946 01b6 E0EC      		ldi r30,lo8(448)
 947 01b8 F1E0      		ldi r31,hi8(448)
 948 01ba 8091 CF01 		lds r24,463
 949 01be 87FD      		sbrc r24,7
 950 01c0 00C0      		rjmp .L38
 951               	.LBE69:
 952               	.LBE68:
 366:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 367:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 368:eeprom_driver.c **** 
 369:eeprom_driver.c **** 	/* Calculate page address */
 370:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 954               	.LM69:
 955 01c2 892F      		mov r24,r25
 956 01c4 90E0      		ldi r25,lo8(0)
 957 01c6 B5E0      		ldi r27,5
 958 01c8 880F      	1:	lsl r24
 959 01ca 991F      		rol r25
 960 01cc BA95      		dec r27
 961 01ce 01F4      		brne 1b
 371:eeprom_driver.c **** 
 372:eeprom_driver.c **** 	/* Set address. */
 373:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 963               	.LM70:
 964 01d0 8093 C001 		sts 448,r24
 374:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 966               	.LM71:
 967 01d4 892F      		mov r24,r25
 968 01d6 8F71      		andi r24,lo8(31)
 969 01d8 8183      		std Z+1,r24
 375:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 971               	.LM72:
 972 01da 1282      		std Z+2,__zero_reg__
 376:eeprom_driver.c **** 
 377:eeprom_driver.c **** 	/* Issue EEPROM Split Write command. */
 378:eeprom_driver.c ****         NVM.CMD = NVM_CMD_WRITE_EEPROM_PAGE_gc;
 974               	.LM73:
 975 01dc 84E3      		ldi r24,lo8(52)
 976 01de 8287      		std Z+10,r24
 977               	.LBB70:
 978               	.LBB71:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 980               	.LM74:
 981 01e0 EBEC      		ldi r30,lo8(459)
 982 01e2 F1E0      		ldi r31,hi8(459)
 983 01e4 21E0      		ldi r18,lo8(1)
 984 01e6 30E0      		ldi r19,hi8(1)
 985 01e8 88ED      		ldi r24,lo8(216)
 986 01ea 90E0      		ldi r25,hi8(216)
 987               	/* #APP */
 988               	 ;  65 "eeprom_driver.c" 1
 989 01ec 84BF      		out 52, r24
 990 01ee 2083      		st z, r18
 991               	 ;  0 "" 2
 992               	/* epilogue start */
 993               	/* #NOAPP */
 994               	.LBE71:
 995               	.LBE70:
 379:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 380:eeprom_driver.c **** }
 997               	.LM75:
 998 01f0 0895      		ret
 1003               	.Lscope9:
 1005               	.global	EEPROM_EraseAll
 1007               	EEPROM_EraseAll:
 381:eeprom_driver.c **** 
 382:eeprom_driver.c **** /*! \brief Erase entire EEPROM memory.
 383:eeprom_driver.c ****  *
 384:eeprom_driver.c ****  *  This function erases the entire EEPROM memory block to 0xFF.
 385:eeprom_driver.c ****  */
 386:eeprom_driver.c **** void EEPROM_EraseAll( void )
 387:eeprom_driver.c **** {
 1009               	.LM76:
 1010               	.LFBB10:
 1011               	/* prologue: function */
 1012               	/* frame size = 0 */
 1013               	.L42:
 1014               	.LBB72:
 1015               	.LBB73:
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 1017               	.LM77:
 1018 01f2 8091 CF01 		lds r24,463
 1019 01f6 87FD      		sbrc r24,7
 1020 01f8 00C0      		rjmp .L42
 1021               	.LBE73:
 1022               	.LBE72:
 388:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 389:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 390:eeprom_driver.c **** 
 391:eeprom_driver.c **** 	/* Issue EEPROM Erase All command. */
 392:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_EEPROM_gc;
 1024               	.LM78:
 1025 01fa 80E3      		ldi r24,lo8(48)
 1026 01fc E0EC      		ldi r30,lo8(448)
 1027 01fe F1E0      		ldi r31,hi8(448)
 1028 0200 8287      		std Z+10,r24
 1029               	.LBB74:
 1030               	.LBB75:
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
 1032               	.LM79:
 1033 0202 EBEC      		ldi r30,lo8(459)
 1034 0204 F1E0      		ldi r31,hi8(459)
 1035 0206 21E0      		ldi r18,lo8(1)
 1036 0208 30E0      		ldi r19,hi8(1)
 1037 020a 88ED      		ldi r24,lo8(216)
 1038 020c 90E0      		ldi r25,hi8(216)
 1039               	/* #APP */
 1040               	 ;  65 "eeprom_driver.c" 1
 1041 020e 84BF      		out 52, r24
 1042 0210 2083      		st z, r18
 1043               	 ;  0 "" 2
 1044               	/* epilogue start */
 1045               	/* #NOAPP */
 1046               	.LBE75:
 1047               	.LBE74:
 393:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 394:eeprom_driver.c **** }
 1049               	.LM80:
 1050 0212 0895      		ret
 1052               	.Lscope10:
 1054               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 eeprom_driver.c
     /tmp/ccbC1kuc.s:2      *ABS*:0000003f __SREG__
     /tmp/ccbC1kuc.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccbC1kuc.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccbC1kuc.s:5      *ABS*:00000034 __CCP__
     /tmp/ccbC1kuc.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccbC1kuc.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccbC1kuc.s:404    .text:00000000 EEPROM_WriteByte
     /tmp/ccbC1kuc.s:526    .text:00000070 EEPROM_ReadByte
     /tmp/ccbC1kuc.s:608    .text:000000be EEPROM_WaitForNVM
     /tmp/ccbC1kuc.s:629    .text:000000c8 EEPROM_FlushBuffer
     /tmp/ccbC1kuc.s:683    .text:000000f2 EEPROM_LoadByte
     /tmp/ccbC1kuc.s:728    .text:00000110 EEPROM_LoadPage
     /tmp/ccbC1kuc.s:786    .text:00000138 EEPROM_AtomicWritePage
     /tmp/ccbC1kuc.s:860    .text:00000176 EEPROM_ErasePage
     /tmp/ccbC1kuc.s:934    .text:000001b4 EEPROM_SplitWritePage
     /tmp/ccbC1kuc.s:1007   .text:000001f2 EEPROM_EraseAll

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
